<?php
// $Id$

/**
 * @file
 * Integrates into project to provide an automated testing hub.
 *
 * Copyright 2008-2009 by Jimmy Berry ("boombatower", http://drupal.org/user/214218)
 */

/*
 * Variables loaded as constants.
 */
define('PIFT_FREQUENCY', variable_get('pift_frequency', -1));
define('PIFT_LAST', variable_get('pift_last', 0));
define('PIFT_KEY', variable_get('pift_key', ''));
define('PIFT_SERVER', variable_get('pift_server', ''));
define('PIFT_DESCRIPTION', variable_get('pift_description', ''));
define('PIFT_FOLLOWUP_FAIL', variable_get('pift_followup_fail', 0));
define('PIFT_FOLLOWUP_RETEST', variable_get('pift_followup_retest', 0));
define('PIFT_REGEX', variable_get('pift_regex', '/(\.diff|\.patch)$/'));
define('PIFT_PID', variable_get('pift_pid', -1));
define('PIFT_RETEST', variable_get('pift_retest', 24 * 60 * 60));
define('PIFT_DELETE', variable_get('pift_delete', FALSE));
define('PIFT_LAST_CID', variable_get('pift_last_cid', 0));

/**
 * Maximum number of items of the same type to transfer in a single XML-RPC
 * request.
 */
define('PIFT_XMLRPC_MAX', 50);

/**
 * Maximum number of batches to send during a single cron run.
 */
define('PIFT_XMLRPC_MAX_BATCHES', 3);

/**
 * Maximum number of commits to process in a single cron run.
 */
define('PIFT_COMMIT_MAX', 100);

/*
 * Test type codes.
 */
define('PIFT_TYPE_RELEASE', 1);
define('PIFT_TYPE_FILE', 2);

/*
 * Test status codes.
 */
define('PIFT_STATUS_QUEUE', 1);
define('PIFT_STATUS_SENT', 2);
define('PIFT_STATUS_FAIL', 3);
define('PIFT_STATUS_PASS', 4);

if (!defined('PIFR_RESPONSE_ACCEPTED')) {
  /*
   * PIFR XML-RPC response codes.
   */
  define('PIFR_RESPONSE_ACCEPTED', 1);
  define('PIFR_RESPONSE_INVALID_SERVER', 2);
  define('PIFR_RESPONSE_DENIED', 3);

  /*
   * Project type codes.
   */
  define('PIFR_SERVER_PROJECT_TYPE_CORE', 1);
  define('PIFR_SERVER_PROJECT_TYPE_MODULE', 2);
}

/*
 * Load required includes.
 */
module_load_include('project.inc', 'pift');
module_load_include('test.inc', 'pift');

/**
 * Implementation of hook_menu().
 */
function pift_menu() {
  $items = array();

  $items['admin/project/pift'] = array(
    'title' => 'PIFT settings',
    'description' => 'Configure PIFT.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('pift_admin_settings_form'),
    'access arguments' => array('administer projects'),
    'file' => 'pift.admin.inc',
  );
  $items['pift/retest/%'] = array(
    'title' => 'Request to re-test a file',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('pift_pages_retest_confirm_form', 2),
    'access arguments' => array('pift re-test files'),
    'file' => 'pift.pages.inc',
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implementation of hook_perm().
 */
function pift_perm() {
  return array(
    'pift re-test files',
    'pift enable project testing',
  );
}

/**
 * Implementation of hook_theme().
 */
function pift_theme() {
  return array(
    'pift_attachments' => array(
      'arguments' => array(
        'files' => array(),
      ),
      'file' => 'pift.pages.inc',
    ),
    'pift_auto_followup' => array(
      'arguments' => array(
        'message' => '',
        'nid' => 0,
        'cid' => 0,
      ),
    ),
  );
}

/**
 * Implementation of hook_init().
 */
function pift_init() {
  drupal_add_css(drupal_get_path('module', 'pift') . '/pift.css');
}

/**
 * Implementation of hook_cron().
 */
function pift_cron() {
  if (PIFT_DELETE) {
    // An issue comment or node has been deleted, remove related test entries.
    pift_test_delete_files();
    variable_set('pift_delete', FALSE);
  }

  // Check if sending is enabled and that the sending frequency has elapsed.
  $time = time();
  if (PIFT_FREQUENCY != -1 && $time > PIFT_LAST + PIFT_FREQUENCY) {
    module_load_include('cron.inc', 'pift');

    // Requeue all tests that have passed the re-test interval.
    pift_cron_retest();

    // Queue all tests related to any commits that have occured.
    $cid = db_result(db_query('SELECT MAX(cid) FROM {cvs_messages}'));
    $cid = min($cid, PIFT_LAST_CID + PIFT_COMMIT_MAX);
    if ($cid > PIFT_LAST_CID) {
      pift_cron_test_release(PIFT_LAST_CID + 1, $cid);
      variable_set('pift_last_cid', $cid);
    }

    // Send a batch of queued tests.
    pift_cron_queue_batch();

    // Retreive any results that have occured since last cron run.
    pift_cron_retreive_results();

    // Store current time as last run.
    variable_set('pift_last', $time);
  }
}

/**
 * Implementation of hook_form_alter(). Must use generic form_alter() due to
 * comment_upload implementation.
 */
function pift_form_alter(&$form, $form_state, $form_id) {
  if ($form_id == 'comment_form' || $form_id == 'project_issue_node_form') {
    module_load_include('pages.inc', 'pift');
    pift_pages_description_add($form, $form_state, $form_id);
  }
}

/**
 * Implementation of hook_form_alter(): project_issue_project_edit_form.
 */
function pift_form_project_issue_project_edit_form_alter(&$form, $form_state) {
  module_load_include('pages.inc', 'pift');
  pift_pages_project_issue_settings($form, $form_state);
}

/**
 * Implementation of hook_nodeapi().
 */
function pift_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  if ($node->type != 'project_issue' || empty($node->files)) {
    return;
  }

  switch ($op) {
    case 'view':
      if (!$a3 && pift_project_enabled($node->project_issue['pid'])) { // Full view.
        $files = pift_test_get_files_node($node->nid);
        $node->content['pift_files'] = array(
          '#value' => '<div id="pift-results-' . $node->nid . '">' .
                      theme('pift_attachments', $files) . '</div>',
          '#weight' => 50,
        );
        unset($node->content['files']); // Remove old attachments table.
      }
      break;
    case 'insert':
      $proper = pift_nodeapi_clean($node);
      if (pift_test_check_criteria_issue($proper)) {
        $files = upload_load($proper);
        pift_test_add_files($files);
      }
      break;
    case 'delete':
      variable_set('pift_delete', TRUE);
      break;
  }
}

/**
 * Cleanup the inconsistent project_issue property placement.
 *
 * In order to remove the need to a bunch of conditions all over PIFT, convert
 * the inconsistent node format to the one used everywhere else. The
 * inconsistent format is only found during node creation, after a node has
 * been created and hook_load() is used the properties are prefixed by
 * project_issue.
 *
 * @param object $node Node to convert.
 * @return object Properly formatted node.
 * @link http://drupal.org/node/519562
 */
function pift_nodeapi_clean($node) {
  $node->project_issue = array();

  $fields = array('pid', 'rid', 'component', 'category', 'priority', 'assigned', 'sid');
  foreach ($fields as $field) {
    $node->project_issue[$field] = $node->$field;
  }

  return $node;
}

/**
 * Implementation of hook_comment().
 */
function pift_comment(&$comment, $op) {
  $node = pift_comment_load_node($comment);
  if ($node->type != 'project_issue') {
    return;
  }

  switch ($op) {
    case 'view':
      if (!empty($comment->files) && pift_project_enabled($node->project_issue['pid'])) {
        // Remove comment_upload attachments table and generate new one.
        $comment->comment = preg_replace('/<table class="comment-upload-attachments">.*?<\/table>/s', '', $comment->comment);
        $files = pift_test_get_files_comment($comment->cid);
        $comment->comment .= '<div id="pift-results-' . $comment->nid . '-' . $comment->cid . '">' .
                             theme('pift_attachments', $files) . '</div>';
      }
      break;
    case 'insert':
      if (pift_test_check_criteria_issue($node)) {
        if (!empty($comment->files)) {
          // Add attachments to this comment to the send queue.
          $files = comment_upload_load_files($comment['cid']);
          pift_test_add_files($files);
        }

        // Add previously submitted files if issue state changes.
        pift_test_add_previous_files($comment['nid']);
      }
      break;
    case 'delete':
      variable_set('pift_delete', TRUE);
      break;
  }
}

/**
 * Load the parent node for the specified comment.
 *
 * @param mixed $comment Comment information passed to hook_comment().
 * @return object Parent node.
 */
function pift_comment_load_node($comment) {
  // Comment can be a comment object, a form, or form_values.
  if (is_object($comment)) {
    $nid = $comment->nid;
  }
  elseif (is_array($comment)) {
    $nid = is_array($comment['nid']) ? $comment['nid']['#value'] : $comment['nid'];
  }
  return node_load($nid);
}

/**
 * Theme the auto followup comments.
 *
 * @param string $message Comment message.
 * @param integer $nid Node ID containting the failed test.
 * @param integer $cid Comment ID, if applicable, containing the failed test.
 * @return string HTML output.
 */
function theme_pift_auto_followup($type, $nid, $cid) {
  global $user;
  if ($type == 'retest') {
    return t('!user requested that <a href="#@id">failed test</a> be re-tested.',
              array('!user' => theme('username', $user), '@id' => "pift-results-$nid" . ($cid ? "-$cid" : '')));
  }
  elseif ($type == 'fail') {
    return t('The last submitted patch <a href="#@id">failed testing</a>.',
               array('@id' => "pift-results-$nid" . ($cid ? "-$cid" : '')));
  }
  return '';
}

/**
 * Load the core release for the given API term ID.
 *
 * @param integer $api_tid Drupal core API compatibility term ID, of the
 *   vocabulary defined by _project_release_get_api_vid.
 * @return Drupal core release NID.
 * @see _project_release_get_api_vid()
 */
function pift_core_api_release($api_tid) {
  static $api_releases = array();

  if (!isset($api_branches[$api_tid])) {
    $result = db_query('SELECT p.nid
                        FROM {node} n
                        JOIN {project_release_nodes} p
                          ON p.nid = n.nid
                        JOIN {term_node} t
                          ON t.vid = n.vid
                        WHERE p.pid = %d
                        AND p.rebuild = %d
                        AND t.tid = %d
                        ORDER BY n.vid DESC
                        LIMIT 1', PIFT_PID, 1, $api_tid);
    $api_releases[$api_tid] = db_result($result);
  }

  return $api_releases[$api_tid];
}
