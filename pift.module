<?php
// $Id$

/*
 * Variables loaded as constants.
 */
define('PIFT_FREQUENCY', variable_get('pift_frequency', -1));
define('PIFT_KEY', variable_get('pift_key', ''));
define('PIFT_SERVER', variable_get('pift_server', ''));
define('PIFT_DESCRIPTION', variable_get('pift_description', ''));
define('PIFT_FOLLOWUP', variable_get('pift_followup', 'patch (code needs work)'));
define('PIFT_REGEX', variable_get('pift_regex', '/(\.diff|\.patch)$/'));
define('PIFT_STATUS', variable_get('pift_status', 'patch (code needs review), patch (ready to commit)'));
define('PIFT_RETEST', variable_get('pift_retest', 24 * 60 * 60));

/*
 * Test status codes.
 */
define('PIFT_QUEUE', 1);
define('PIFT_PASS', 2);
define('PIFT_FAIL', 3);
define('PIFT_RETEST', 4);

/*
 * PIFR XML-RPC response codes.
 */
if (!defined('PIFR_RESPONSE_ACCEPTED')) {
  define('PIFR_RESPONSE_ACCEPTED', 1);
  define('PIFR_RESPONSE_INVALID_SERVER', 2);
  define('PIFR_RESPONSE_DENIED', 3);
}

/*
 * Load required includes.
 */
module_load_include('project.inc', 'pift');
module_load_include('test.inc', 'pift');

/**
 * Implementation of hook_menu().
 */
function pift_menu() {
  $items = array();

  $items['admin/project/pift'] = array(
    'title' => 'PIFT settings',
    'description' => 'Configure PIFT.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('pift_admin_settings_form'),
    'access arguments' => array('administer projects'),
    'file' => 'pift.admin.inc',
  );
  $items['admin/project/pift/status/%'] = array(
    'title' => 'AHAH status',
    'page callback' => 'pift_admin_status',
    'page arguments' => array(4),
    'access arguments' => array('administer projects'),
    'file' => 'pift.admin.inc',
  );

  $items['pift/retest/%'] = array(
    'title' => 'Request to re-test a file',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('pift_pages_retest_confirm_form', 2),
    'access arguments' => array('pift re-test files'),
    'file' => 'pift.pages.inc',
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implementation of hook_perm().
 */
function pift_perm() {
  return array('pift re-test files');
}

/**
 * Implementation of hook_theme().
 */
function pift_theme() {
  return array(
    'pift_attachments' => array(
      'arguments' => array(
        'files' => array(),
      ),
      'file' => 'pift.pages.inc',
    ),
    'pift_auto_close_message' => array(
      'arguments' => array(
        'last_file' => NULL,
      ),
    ),
  );
}

/**
 * Implementation of hook_init().
 */
function pift_init() {
  drupal_add_css(drupal_get_path('module', 'pift') . '/pift.css');
}

/**
 * Implementation of hook_cron().
 */
function pift_cron() {
  $send = variable_get('pift_send_frequency', -1);
  // Check if sending is enabled.
  if ($send != -1) {
    $time = time();
    // Get time last sent.
    $last_sent = variable_get('pift_last_sent', time());
    $frequency = $send * 60;
    // Time to send again?
    if ($time > ($last_sent + $frequency)) {
      pift_retest_check();
      pift_send_file_data();
      // Update last sent time.
      variable_set('pift_last_sent', $time);
    }
  }
}

/**
 * Implementation of hook_form_alter(). Must use generic form_alter() due to
 * comment_upload implementation.
 */
function pift_form_alter(&$form, $form_state, $form_id) {
  if ($form_id == 'comment_form' || $form_id == 'project_issue_node_form') {
    module_load_include('pages.inc', 'pift');
    pift_pages_description_add($form, $form_state, $form_id);
  }
}

/**
 * Implementation of hook_form_alter(): project_issue_project_edit_form.
 */
function pift_form_project_issue_project_edit_form_alter(&$form, $form_state) {
  module_load_include('pages.inc', 'pift');
  pift_pages_project_issue_settings($form, $form_state);
}

/**
 * Implementation of hook_nodeapi().
 */
function pift_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  if ($node->type != 'project_issue') {
    return;
  }

  switch ($op) {
    case 'view':
      if (!$a3) { // Full view.
        if (isset($node->files)) {
          $files = pift_test_get_files_node($node->nid);
          $node->content['pift_files'] = array(
            '#value' => '<div id="pift-results-' . $node->nid . '">' .
                        theme('pift_attachments', $files) . '</div>',
            '#weight' => 50,
          );
        }
        unset($node->content['files']);
      }
      break;
    case 'insert':
      $files = upload_load($node);
      pift_add_issue_files($files);
      break;
    case 'update':
      // If files were deleted, remove related data in the test results table.
      if (is_array($node->files)) {
        foreach ($node->files as $file) {
          // Can be either an array or object as this point.
          $file = (object) $file;
          if ($file->remove) {
            db_query("DELETE FROM {pift_data} WHERE nid = %d AND fid = %d", $node->nid, $file->fid);
          }
        }
      }
      break;
    case 'delete':
      db_query("DELETE FROM {pift_data} WHERE nid = %d", $node->nid);
      break;
  }
}

/**
 * Implementation of hook_comment().
 */
function pift_comment(&$comment, $op) {
  // Comment can be a comment object, a form, or form_values.
  if (is_object($comment)) {
    $nid = $comment->nid;
  }
  elseif (is_array($comment)) {
    $nid = is_array($comment['nid']) ? $comment['nid']['#value'] : $comment['nid'];
  }
  $node = node_load($nid);
  if ($node->type != 'project_issue') {
    return;
  }

  switch ($op) {
    case 'view':
      if (!isset($comment->files)) {
        return;
      }

      // Remove comment_upload attachments table and generate new one.
      $comment->comment = preg_replace('/<table class="comment-upload-attachments">.*?<\/table>/s', '', $comment->comment);
      $files = pift_test_get_files_comment($comment->cid);
      $comment->comment .= '<div id="pift-results-' . $comment->nid . '-' . $comment->cid . '">' .
                           theme('pift_attachments', $files) . '</div>';
      break;
    case 'insert':
      // Add attachments to this comment to the send queue.
      $files = comment_upload_load_files($comment['cid']);
      pift_add_followup_files($files);
      pift_check_followup_metadata($comment);
      break;
    case 'update':
      // If files were deleted, remove related data in the test results table.
      if (is_array($comment['files'])) {
        foreach ($comment['files'] as $file) {
          // Can be either an array or object as this point.
          $file = (object) $file;
          if ($file->remove) {
            db_query("DELETE FROM {pift_data} WHERE cid = %d AND fid = %d", $comment['cid'], $file->fid);
          }
        }
      }
      break;
    case 'delete':
      // Remove related data in the test results table.
      db_query("DELETE FROM {pift_data} WHERE cid = %d", $comment->cid);
      break;
  }
}

/**
 * Empties the send queue.
 */
function pift_reset_send_queue() {
  variable_set('pift_last_sent', time());
  // Remove all untested files.
  // TODO: Do we really want to do this??
  db_query("DELETE FROM {pift_data} WHERE status = %d", PIFT_UNTESTED);
}

/**
 * Adds issue attachments matching PIFT_FILE_REGEX to the send queue.
 *
 * @param $files
 *   An array of file objects.
 */
function pift_add_issue_files($files) {
  global $user;
  if (is_array($files)) {
    foreach ($files as $file) {
      // Put the file data into the send queue.
      if (preg_match(PIFT_FILE_REGEX, $file->filename) && file_exists($file->filepath)) {
        db_query("INSERT INTO {pift_data} (fid, nid, cid, uid, display_data, status, timestamp) VALUES (%d, %d, %d, %d, '%s', %d, %d)", $file->fid, $file->nid, 0, $user->uid, '', PIFT_UNTESTED, 0);
      }
    }
  }
}

/**
 * Add followup attachments matching PIFT_FILE_REGEX to the send queue.
 *
 * @param $files
 *   An array of file objects.
 */
function pift_add_followup_files($files) {
  global $user;
  if (is_array($files)) {
    foreach ($files as $file) {
      // This blows, but comment_upload now stores files as arrays,
      // not objects, so cast here.
      $file = (object) $file;
      // Put the file data into the send queue.
      if (preg_match(PIFT_FILE_REGEX, $file->filename) && file_exists($file->filepath)) {
        db_query("INSERT INTO {pift_data} (fid, nid, cid, uid, display_data, status, timestamp) VALUES (%d, %d, %d, %d, '%s', %d, %d)", $file->fid, $file->nid, $file->cid, $user->uid, '', PIFT_UNTESTED, 0);
      }
    }
  }
}

/**
 * Manually requests patch re-testing.
 */
function pift_request_retest_confirm_form_submit($form, &$form_state) {
  $file_info = $form['#file_info'];
  // Check issue filters here to provide an intelligent user
  // message to the user if the filters don't pass.
  if (pift_check_issue_filters($file_info->nid)) {
    // Mark for re-testing.  Set last tested timestamp to zero here
    // so the file doesn't have to wait the whole PIFT_RETEST period
    // to be sent for testing -- the timestamp will be updated as soon
    // as the file is sent anyways.
    db_query("UPDATE {pift_data} SET display_data = '%s', status = %d, timestamp = %d WHERE ftid = %d", 'manual re-test', PIFT_RETEST, 0, $file_info->ftid);
    // In case the file was removed from the testable files list
    // from the time it was submitted.
    if (db_affected_rows()) {
      drupal_set_message(t('%file has been submitted for re-testing -- results will be posted when testing completes.', array('%file' => $file_info->filename)));
    }
    else {
      drupal_set_message(t('Invalid file submitted.'), 'error');
    }
  }
  else {
    drupal_set_message(t('%file is not currently eligible for re-testing, and was not submitted.', array('%file' => $file_info->filename)), 'error');
  }

  $form_state['redirect'] = "node/$file_info->nid";
}

/**
 * Marks previously passed files for re-testing, if:
 *   1. The file's last test is older than the retest interval.
 *   2. The file is part of a project that's being tested.
 *   3. The file is attached to an issue that has one of the
 *      issue states marked for testing.
 *
 */
function pift_retest_check() {

  // Never re-test files.
  if (PIFT_RETEST_TIME == '-1') {
    return;
  }

  // Set up the retest time limit.
  $retest_time = time() - (PIFT_RETEST_TIME * 60 * 60);

  $where = '';
  $where_parts = array();
  $args = array(PIFT_RETEST, PIFT_PASSED, $retest_time);

  // Restrict to listed projects, if set.
  if ($projects = pift_project_list()) {
    $where_parts[] = ' p.nid IN ('. implode(',', array_fill(0, count($projects), '%d')) .')';
    $args = array_merge($args, $projects);
  }

  // Restrict to the status list, if set.
  if ($status_list = pift_status_list()) {
    $where_parts[] = 'pi.sid IN ('. implode(',', array_fill(0, count($status_list), '%d')) .')';
    $args = array_merge($args, $status_list);
  }

  // Add in release info if it exists.
  if (module_exists('project_release')) {
    // Restrict to release tag, if set.
    if ($release_tag_regex = variable_get('pift_release_tag_regex', '')) {
      $join = ' INNER JOIN {project_release_nodes} prn ON pi.rid = prn.nid';
      $where_parts[] = "prn.tag REGEXP '%s'";
      $args[] = $release_tag_regex;
    }
    else {
      $join = '';
    }
  }

  if (!empty($where_parts)) {
    $where .= " AND nid IN (SELECT pi.nid FROM {project_issues} pi INNER JOIN {node} p ON p.nid = pi.pid$join WHERE ". implode(' AND ', $where_parts) .")";
  }

  db_query("UPDATE {pift_data} SET status = %d WHERE status = %d AND timestamp < %d$where", $args);
}

/**
 * Sends file data to test servers, in a round robin approach.
 *
 * The files will be sent via XML-RPC to any servers listed on the settings page,
 * which also have a valid Project issue file review module installed and configured
 * with the server key of the PIFT server (available on the PIFT server settings page).
 *
 * The files will be sent in an array, each element of which is an associative array
 * with the following key/value pairs:
 *
 *     'ftid'          => The file test ID that was originally passed from
 *                       the test server for the file in question.
 *
 *     'cid'           => The comment ID of the comment the patch is
 *                        attached to.
 *
 *     'pid'           => The project ID.
 *
 *     'rid'           => The release ID.
 *
 *     'uid'           => The uid of the user who submitted the file.
 *
 *     'issue_id'      => nid of the issue.
 *
 *     'issue_title'   => Title of the issue.
 *
 *     'project'       => Project the patch is for.
 *
 *     'version'       => Project version string.
 *
 *     'tag'           => Release tag as found in {project_release_nodes}.
 *
 *     'submitter'     => Drupal user submitting the patch.
 *
 *     'patch_url'     => The absolute URL for the file.
 */
function pift_send_file_data() {
  global $base_url;

  // Get servers if any exist.
  if ($all_server_data = variable_get('pift_sites', '')) {
    $all_server_data = explode("\n", $all_server_data);
    $servers = array();
    $i = 0;

    // Set up the test servers.
    foreach ($all_server_data as $server_data) {
      if ($server_data) {
        // Set up the login data for the server. The test server needs
        // it's server key for authentication.
        $server_data = explode('@', $server_data);
        $server['server_key'] = $server_data[0];
        $server['xmlrpc_url'] = $server_data[1];
        // Basic testing to make sure the XML-RPC URL isn't totally bogus.
        if (preg_match('/^(http|https):\/\/.+\/xmlrpc.php/', $server['xmlrpc_url'])) {
          $i++;
          $servers[$i] = $server;
        }
        // Bad server URL.
        else {
          watchdog('project_remote', '%server is an invalid URL.', array('%server' => $server_xmlrpc_url), WATCHDOG_ERROR);
        }
      }
    }
    if (empty($servers)) {
      return;
    }
  }
  else {
    return;
  }

  // Set up the resend time limit.
  $resend_time = time() - (PIFT_RESEND_TIME * 60 * 60);
  $retest_time = time() - (PIFT_RETEST_TIME * 60 * 60);

  $where = '';
  $where_args = array();
  $sub_query_args = array(PIFT_UNTESTED, $resend_time, PIFT_RETEST, $retest_time, 0);

  // Restrict to listed projects, if set.
  if ($projects = pift_project_list()) {
    $where .= ' AND p.nid IN ('. implode(',', array_fill(0, count($projects), '%d')) .')';
    $where_args = array_merge($where_args, $projects);
  }

  // Restrict to the status list, if set.
  if ($status_list = pift_status_list()) {
    $where .= ' AND pi.sid IN ('. implode(',', array_fill(0, count($status_list), '%d')) .')';
    $where_args = array_merge($where_args, $status_list);
  }

  // Add in release info if it exists.
  if (module_exists('project_release')) {
    $select = ', prn.version, prn.tag';
    $join = ' LEFT JOIN {project_release_nodes} prn ON pi.rid = prn.nid';
    // Restrict to release tag, if set.
    if ($release_tag_regex = variable_get('pift_release_tag_regex', '')) {
      $where .= " AND prn.tag REGEXP '%s'";
      $where_args[] = $release_tag_regex;
    }
  }
  else {
    $select = '';
    $join = '';
  }

  // Assemble final args.
  $args = array_merge($sub_query_args, $where_args, $sub_query_args, $where_args);

  // Pull issue files that need to be sent for testing.  These include:
  // 1. All files marked as untested that have exceeded the resend period.
  //    since their last send (includes newly added files).
  // 2. All files that have been marked for re-testing.
  // This is one god awful query...  :(
  $files = db_query_range("(SELECT pd.ftid, pd.cid, n.nid AS issue_id, n.title AS issue_title, n.uid, pi.pid, pi.rid, f.filepath AS patch_url, p.title AS project, u.name AS submitter$select FROM {pift_data} pd INNER JOIN {project_issues} pi ON pd.nid = pi.nid INNER JOIN {files} f ON pd.fid = f.fid INNER JOIN {node} n ON n.nid = pi.nid INNER JOIN {node} p ON p.nid = pi.pid INNER JOIN {users} u ON u.uid = pd.uid$join WHERE ((pd.status = %d AND pd.timestamp < %d) OR (pd.status = %d AND pd.timestamp < %d)) AND pd.cid = %d$where) UNION (SELECT pd.ftid, pd.cid, n.nid AS issue_id, n.title AS issue_title, n.uid, pi.pid, pi.rid, f.filepath AS patch_url, p.title AS project, u.name AS submitter$select FROM {pift_data} pd INNER JOIN {project_issues} pi ON pd.nid = pi.nid INNER JOIN {files} f ON pd.fid = f.fid INNER JOIN {node} n ON n.nid = pi.nid INNER JOIN {node} p ON p.nid = pi.pid INNER JOIN {users} u ON u.uid = pd.uid$join WHERE ((pd.status = %d AND pd.timestamp < %d) OR (pd.status = %d AND pd.timestamp < %d)) AND pd.cid <> %d$where) ORDER BY ftid", $args, 0, PIFT_SEND_LIMIT);

  // Set up the batching variables.
  $bid = 0;
  $batches = array();
  $batch_total = 0;
  $sent_files = array();

  // Send new data if there is any.
  while ($file = db_fetch_array($files)) {
    if (is_readable($file['patch_url'])) {
      // Start the next batch if the current one is full.
      if ($batch_total >= PIFT_BATCH_SIZE) {
        $bid++;
        $batch_total = 0;
      }
      // Convert filepath to absolute URL.
      $file['patch_url'] = url($file['patch_url'], array('absolute' => TRUE));
      // Add the file to the current batch.
      $batches[$bid][] = $file;
      // Add to the list of files that will be sent with this batch.
      $sent_files[$bid][] = $file['ftid'];
      // Increment both the current batch size, and the total size.
      $batch_total++;
    }
    // File is not readable, mark as such.
    else {
      db_query("UPDATE {pift_data} SET status = %d WHERE ftid = %d", PIFT_NOT_READABLE, $file['ftid']);
    }
  }

  // Nothing to do.
  if (empty($batches)) {
    return;
  }

  $sent = array();

  // Get the next server in the round robin cycle.
  $s = variable_get('pift_next_test_server', 1);

  $server_key = pift_server_key();

  // Send batches, round robin.
  foreach ($batches as $bid => $batch) {
    // We're at the end of the server line, start over.
    if ($s > $i) {
      $s = 1;
    }
    // Send batch.
    $result = xmlrpc($servers[$s]['xmlrpc_url'], 'pifr.batch.queue', $server_key, $batch);

    // List of successful sends.
    if ($result == PIFR_RESPONSE_ACCEPTED) {
      // Update the last sent timestamp for this batch of files.
      db_query("UPDATE {pift_data} SET timestamp = %d WHERE ftid IN (". implode(', ', $sent_files[$bid]) .")", time());
      $sent[] = check_plain($servers[$s]['xmlrpc_url']) .' -- '. format_plural(count($sent_files[$bid]), '1 file sent', '@count files sent');
    }

    // Failed XML-RPC call.
    elseif ($result === FALSE) {
      pift_xmlrpc_error_handler($servers[$s]);
    }
    // Failed test server validation.
    else {
      pift_xmlrpc_error_handler($servers[$s], $result);
    }

    // Next server in line.
    $s++;
    variable_set('pift_next_test_server', $s);
  }

  // Record successful sends.
  if (!empty($sent)) {
    watchdog('project_remote', 'Project issue data sent successfully to the following servers:!servers', array('!servers' => theme('item_list', $sent)));
  }
}

/**
 * Checks an issue to see if it still passes testable file filters.
 *
 * @param $nid
 *   The issue node the file is attached to.
 */
function pift_check_issue_filters($nid) {

  $join = '';
  $where = '';
  $args = array($nid);
  return TRUE;

  // Restrict to listed projects, if set.
  if ($projects = pift_project_list()) {
    $where .= ' AND pi.pid IN ('. implode(',', array_fill(0, count($projects), '%d')) .')';
    $args = array_merge($args, $projects);
  }

  // Restrict to the status list, if set.
  if ($status_list = pift_status_list()) {
    $where .= ' AND pi.sid IN ('. implode(',', array_fill(0, count($status_list), '%d')) .')';
    $args = array_merge($args, $status_list);
  }

  // Restrict to release tag, if set.
  if (module_exists('project_release')) {
    if ($release_tag_regex = variable_get('pift_release_tag_regex', '')) {
      $join = ' LEFT JOIN {project_release_nodes} prn ON pi.rid = prn.nid';
      $where .= " AND prn.tag REGEXP '%s'";
      $args[] = $release_tag_regex;
    }
  }

  // Pull last testable file for the issue.
  $passed_filters = db_result(db_query("SELECT pi.nid FROM {project_issues} pi$join WHERE pi.nid = %d$where", $args));

  return $passed_filters;
}

/**
 * Checks a file to see if an auto status change is needed.
 *
 * Only files that have failed testing are eligible.  If the
 * auto followup sid is set, and the file failed testing, and the
 * file is the last testable file posted to the issue, then it
 * leaves a followup setting the issue sid to the auto followup
 * sid.
 *
 * @param $file
 *   An associative array of file test result information,
 *   with the following key/value pairs:
 *
 *     ftid     => The file test ID passed to the testing server.
 *     issue_id => The issue node the file is attached to.
 *     status   => The test result, should be on of the
 *                 constants PIFT_PASSED, PIFT_FAILED
 */
function pift_check_auto_followup($file) {

  // Only if an auto change followup sid is set, and only for failed files.
  if (variable_get('pift_auto_followup_sid', 0) && $file['status'] == PIFT_FAILED) {
    $join = '';
    $where = '';
    $args = array($file['issue_id']);

    // Restrict to listed projects, if set.
    if ($projects = pift_project_list()) {
      $where .= ' AND pi.pid IN ('. implode(',', array_fill(0, count($projects), '%d')) .')';
      $args = array_merge($args, $projects);
    }

    // Restrict to the status list, if set.
    if ($status_list = pift_status_list()) {
      $where .= ' AND pi.sid IN ('. implode(',', array_fill(0, count($status_list), '%d')) .')';
      $args = array_merge($args, $status_list);
    }

    // Restrict to release tag, if set.
    if (module_exists('project_release')) {
      if ($release_tag_regex = variable_get('pift_release_tag_regex', '')) {
        $join = ' LEFT JOIN {project_release_nodes} prn ON pi.rid = prn.nid';
        $where .= " AND prn.tag REGEXP '%s'";
        $args[] = $release_tag_regex;
      }
    }

    // Pull last testable file for the issue.
    $last_file = db_fetch_object(db_query_range("SELECT pd.ftid, pd.nid, pd.cid, pd.status FROM {pift_data} pd INNER JOIN {project_issues} pi ON pd.nid = pi.nid$join WHERE pd.nid = %d$where ORDER BY ftid DESC", $args, 0, 1));

    // There's an attached testable file on the issue, and
    // the file in question is the last file attached to the
    // issue.
    if ($last_file && $file['ftid'] == $last_file->ftid) {
      pift_auto_followup($last_file);
    }
  }
}

/**
 * Posts a followup to an issue.
 *
 * Sets the issue sid to the auto followup sid.
 *
 * @param $last_file
 *   A testable file object.
 */
function pift_auto_followup($last_file) {

  project_issue_add_followup(array(
    'nid' => $last_file->nid,
    'sid' => variable_get('pift_auto_followup_sid', 0),
    'comment' => theme('pift_auto_close_message', $last_file),
  ));
}

function pift_check_followup_metadata($comment) {

  $auto_followup_sid = variable_get('pift_auto_followup_sid', 0);

  // If no auto followup sid exists, then this check isn't necessary.
  if (!$auto_followup_sid) {
    return;
  }

  $projects = pift_project_list();
  $status_list = pift_status_list();
  $pid = $comment['project_info']['pid'];
  $sid = $comment['sid'];
  $rid = $comment['project_info']['rid'];
  $nid = $comment['nid'];
  $release_tag_regex = variable_get('pift_release_tag_regex', '');

  // Only proceed with checking if the current project and issue
  // status pass the filters. There's no easy way to check the
  // release tag filter here, so we'll check it when we pull the
  // last testable file.
  if ((empty($projects) || in_array($pid, $projects)) && (empty($status_list) || in_array($sid, $status_list))) {
    // We have to check to see if either pid, sid, or rid
    // has actually changed. There's no reliable way to do this
    // without querying {project_issue_comments} for it.
    $last_post = db_fetch_object(db_query_range("SELECT pid, sid, rid FROM {project_issue_comments} WHERE nid = %d AND cid <> %d ORDER BY cid DESC", $nid, $comment['cid'], 0, 1));
    // This comment being inserted is the first followup, so get
    // pid, sid, and rid from the issue itself.
    if (!$last_post) {
      $last_post = db_fetch_object(db_query("SELECT pid, sid, rid FROM {project_issues} WHERE nid = %d", $nid));
    }
    // A metadata change only matters if a filter is set, and
    // we need at least one piece of metadata to have changed.
    $metadata_change = (!empty($projects) && $last_post->pid != $pid) || (!empty($status_list) && $last_post->sid != $sid) || (!empty($release_tag_regex) && $last_post->rid != $rid);
    // Continue if there was a metadata change, except
    // in the special case where a user is trying to manually
    // set the issue state from the auto followup state to a testable
    // state, we want to allow this.
    if ($metadata_change && $last_post->sid != $auto_followup_sid) {
      $join = '';
      $where = '';
      $args = array($nid);
      // Restrict to release tag, if set.
      if (module_exists('project_release') && $release_tag_regex) {
        $join = ' INNER JOIN {project_issues} pi ON pd.nid = pi.nid LEFT JOIN {project_release_nodes} prn ON pi.rid = prn.nid';
        $where .= " AND prn.tag REGEXP '%s'";
        $args[] = $release_tag_regex;
      }

      // Pull last testable file for the issue.
      $last_file = db_fetch_object(db_query_range("SELECT pd.nid, pd.cid, pd.status FROM {pift_data} pd$join WHERE pd.nid = %d$where ORDER BY ftid DESC", $args, 0, 1));

      // There's an attached testable file on the issue, and
      // the last testable file has failed testing.
      if ($last_file && $last_file->status == PIFT_FAILED) {
        pift_auto_followup($last_file);
      }
    }
  }
}

/**
 * Themes the comment posted on auto followups.
 *
 * @param $last_file
 *   A testable file object.
 */
function theme_pift_auto_close_message($last_file) {

  $output = '';
  $id = "#file-test-results-$last_file->nid";
  if ($last_file->cid) {
    $id .= "-$last_file->cid";
  }
  $output .= t('The last submitted patch <a href="@link">failed testing</a>.', array('@link' => $id));

  return $output;
}

/**
 * Records XML-RPC errors communicating to test servers.
 *
 * @param $server
 *   An associative array of server information, as follows:
 *     'user' => The user logging in.
 *     'xmlrpc_url' => The XML-RPC URL of the test server.
 *     'url'  => The Drupal base URL of the server sending the data.
 *
 * @param $error_code
 *   Optional. A string representing a validation error type.
 */
function pift_xmlrpc_error_handler($server, $error_code = NULL) {
  global $base_url;

  $t_args = array('%url' => $base_url, '%xmlrpc_url' => $server['xmlrpc_url']);

  switch ($error_code) {
    case PIFR_RESPONSE_INVALID_SERVER:
      watchdog('project_remote', 'Unable to log in %url to %xmlrpc_url -- invalid server key.', $t_args, WATCHDOG_ERROR);
      break;
    default:
      watchdog('project_remote', 'XML-RPC error communicating with %xmlrpc_url', $t_args, WATCHDOG_ERROR);
      break;
  }
}
