<?php
// $Id$

/*
 * Variables loaded as constants.
 */
define('PIFT_FREQUENCY', variable_get('pift_frequency', -1));
define('PIFT_KEY', variable_get('pift_key', ''));
define('PIFT_SERVER', variable_get('pift_server', ''));
define('PIFT_DESCRIPTION', variable_get('pift_description', ''));
define('PIFT_FOLLOWUP', variable_get('pift_followup', 'patch (code needs work)'));
define('PIFT_REGEX', variable_get('pift_regex', '/(\.diff|\.patch)$/'));
define('PIFT_STATUS', variable_get('pift_status', 'patch (code needs review), patch (ready to commit)'));
define('PIFT_RETEST', variable_get('pift_retest', 24 * 60 * 60));

/*
 * Test status codes.
 */
define('PIFT_UNTESTED', 0);
define('PIFT_PASSED', 1);
define('PIFT_FAILED', 2);
define('PIFT_RETEST', 3);
define('PIFT_NOT_READABLE', 4);

/*
 * PIFR XML-RPC response codes.
 */
if (!defined('PIFR_RESPONSE_ACCEPTED')) {
  define('PIFR_RESPONSE_ACCEPTED', 1);
  define('PIFR_RESPONSE_INVALID_SERVER', 2);
  define('PIFR_RESPONSE_DENIED', 3);
}

/*
 * Load required includes.
 */
module_load_include('project.inc', 'pift');

/**
 * Implementation of hook_menu().
 */
function pift_menu() {
  $items = array();

  $items['admin/project/pift'] = array(
    'title' => 'PIFT settings',
    'description' => 'Configure PIFT.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('pift_admin_settings_form'),
    'access arguments' => array('administer projects'),
    'file' => 'pift.admin.inc',
  );
  $items['admin/project/pift/status/%'] = array(
    'title' => 'AHAH status',
    'page callback' => 'pift_admin_status',
    'page arguments' => array(4),
    'access arguments' => array('administer projects'),
    'file' => 'pift.admin.inc',
  );
  // Manual request for re-test.
  $items['pift-server-request-retest'] = array(
    'title' => 'Request to re-test a file',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('pift_request_retest_confirm_form'),
    'access callback' => 'user_access',
    'access arguments' => array('re-test files'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implementation of hook_perm().
 */
function pift_perm() {
  return array('re-test files');
}

/**
 * Implementation of hook_theme().
 */
function pift_theme() {
  return array(
    'pift_results' => array(
      'arguments' => array(
        'results' => NULL,
        'nid' => NULL,
        'cid' => NULL,
        'retest' => NULL,
      ),
    ),
    'pift_auto_close_message' => array(
      'arguments' => array(
        'last_file' => NULL,
      ),
    ),
  );
}

/**
 * Implementation of hook_init().
 */
function pift_init() {
  drupal_add_css(drupal_get_path('module', 'pift_server') . '/pift.css');
}

/**
 * Implementation of hook_cron().
 */
function pift_cron() {
  $send = variable_get('pift_send_frequency', -1);
  // Check if sending is enabled.
  if ($send != -1) {
    $time = time();
    // Get time last sent.
    $last_sent = variable_get('pift_last_sent', time());
    $frequency = $send * 60;
    // Time to send again?
    if ($time > ($last_sent + $frequency)) {
      pift_retest_check();
      pift_send_file_data();
      // Update last sent time.
      variable_set('pift_last_sent', $time);
    }
  }
}

/**
 * Implementation of hook_form_alter(). Must use generic form_alter() due to
 * comment_upload implementation.
 */
function pift_form_alter(&$form, $form_state, $form_id) {
  if ($form_id == 'comment_form' || $form_id == 'project_issue_node_form') {
    module_load_include('pages.inc', 'pift');
    pift_pages_description_add($form, $form_state, $form_id);
  }
}

/**
 * Implementation of hook_form_alter(): project_issue_project_edit_form.
 */
function pift_form_project_issue_project_edit_form_alter(&$form, $form_state) {
  module_load_include('pages.inc', 'pift');
  pift_pages_project_issue_settings($form, $form_state);
}

/**
 * Empties the send queue.
 */
function pift_reset_send_queue() {
  variable_set('pift_last_sent', time());
  // Remove all untested files.
  // TODO: Do we really want to do this??
  db_query("DELETE FROM {pift_data} WHERE status = %d", PIFT_UNTESTED);
}

/**
 * Adds issue attachments matching PIFT_FILE_REGEX to the send queue.
 *
 * @param $files
 *   An array of file objects.
 */
function pift_add_issue_files($files) {
  global $user;
  if (is_array($files)) {
    foreach ($files as $file) {
      // Put the file data into the send queue.
      if (preg_match(PIFT_FILE_REGEX, $file->filename) && file_exists($file->filepath)) {
        db_query("INSERT INTO {pift_data} (fid, nid, cid, uid, display_data, status, timestamp) VALUES (%d, %d, %d, %d, '%s', %d, %d)", $file->fid, $file->nid, 0, $user->uid, '', PIFT_UNTESTED, 0);
      }
    }
  }
}

/**
 * Add followup attachments matching PIFT_FILE_REGEX to the send queue.
 *
 * @param $files
 *   An array of file objects.
 */
function pift_add_followup_files($files) {
  global $user;
  if (is_array($files)) {
    foreach ($files as $file) {
      // This blows, but comment_upload now stores files as arrays,
      // not objects, so cast here.
      $file = (object) $file;
      // Put the file data into the send queue.
      if (preg_match(PIFT_FILE_REGEX, $file->filename) && file_exists($file->filepath)) {
        db_query("INSERT INTO {pift_data} (fid, nid, cid, uid, display_data, status, timestamp) VALUES (%d, %d, %d, %d, '%s', %d, %d)", $file->fid, $file->nid, $file->cid, $user->uid, '', PIFT_UNTESTED, 0);
      }
    }
  }
}

/**
 * Adds debug file testing links upon submission of testable patches.
 *
 * @param $file
 *   A testable file object, with PIFT's ftid included.
 */
function pift_build_file_testing_links($file) {
  $pass = PIFT_PASSED;
  $fail = PIFT_FAILED;
  $query = "destination=node/$file->nid";
  if (isset($file->cid)) {
    $query .= "#comment-$file->cid";
  }

  $for_file = t(' for file %file', array('%file' => $file->filename));

  $links = '';
  $links .= '<div>';
  $links .= l(t("Manually pass testing"), "pift-server-file-testing-link/$file->ftid/$pass", array('query' => $query)) . $for_file;
  $links .= '</div><div>';
  $links .= l(t("Manually fail testing"), "pift-server-file-testing-link/$file->ftid/$fail", array('query' => $query)) . $for_file;
  $links .= '</div>';

  return $links;
}

/**
 * Callback for manually submitting patch test results.
 *
 * Useful for debugging.
 *
 * @param $ftid
 *   PIFT's file testing ID
 * @param $nid
 *   The issue node ID.
 * @param $cid
 *   Followup comment ID, or zero for an initial issue post.
 * @param $status
 *   Status to set the test result to.  Should be one of
 *   PIFT_PASSED, PIFT_FAILED
 */
function pift_debug_file_testing_link($ftid, $status) {
  if (variable_get('pift_debug_file_testing_link', '')) {
    // Make sure we have all numeric args.
    $args = func_get_args();
    foreach ($args as $arg) {
      if (!is_numeric($arg)) {
        drupal_set_message(t('non-numeric argument passed'), 'error');
        drupal_goto();
      }
    }
    switch ((int) $status) {
      case PIFT_PASSED:
        $display_data = t('file passed testing');
        break;
      case PIFT_FAILED:
        $display_data = t('file failed testing');
        break;
      default:
        $display_data = '';
        break;
    }
    $file = array(
      'ftid' => $ftid,
      'status' => $status,
      'display_data' => $display_data,
    );
    pift_process_files(array($file));
    drupal_goto();
  }
  else {
    drupal_access_denied();
  }

}

/**
 * Builds form for confirming patch retesting.
 *
 * @param $nid
 *   The node ID of the issue the patch is attached to.
 * @param $cid
 *   The comment ID of the followup the patch is attached
 *   to, if any.
 * @param $ftid
 *   The file testing ID of the file to be sent for retesting.
 * @return
 *   A form array.
 *
 */
function pift_request_retest_confirm_form($form_state, $nid, $cid, $ftid) {

  // Make sure we have all numeric args.
  $args = func_get_args();
  array_shift($args);
  foreach ($args as $arg) {
    if (!is_numeric($arg)) {
      drupal_set_message(t('non-numeric argument passed'), 'error');
      drupal_goto("node/$nid");
    }
  }

  if ($cid) {
    $file_info = db_fetch_object(db_query("SELECT pd.ftid, pd.nid, f.filename FROM {pift_data} pd INNER JOIN {files} f ON pd.fid = f.fid WHERE pd.ftid = %d", $ftid));
  }
  else {
    $file_info = db_fetch_object(db_query("SELECT pd.ftid, pd.nid, f.filename FROM {pift_data} pd INNER JOIN {files} f ON pd.fid = f.fid WHERE pd.ftid = %d", $ftid));
  }

  if ($file_info) {
    $form = array();
    $form['#file_info'] = $file_info;

    return confirm_form(
      $form,
      t('Are you sure you want to submit %file for re-testing?', array('%file' => $file_info->filename)),
      'node/'. $file_info->nid,
      '',
      t('Retest file'),
      t('Cancel'));
  }
  else {
    drupal_set_message(t('Invalid file submitted.'), 'error');
    drupal_goto("node/$nid");
  }
}

/**
 * Manually requests patch re-testing.
 */
function pift_request_retest_confirm_form_submit($form, &$form_state) {
  $file_info = $form['#file_info'];
  // Check issue filters here to provide an intelligent user
  // message to the user if the filters don't pass.
  if (pift_check_issue_filters($file_info->nid)) {
    // Mark for re-testing.  Set last tested timestamp to zero here
    // so the file doesn't have to wait the whole PIFT_RETEST period
    // to be sent for testing -- the timestamp will be updated as soon
    // as the file is sent anyways.
    db_query("UPDATE {pift_data} SET display_data = '%s', status = %d, timestamp = %d WHERE ftid = %d", 'manual re-test', PIFT_RETEST, 0, $file_info->ftid);
    // In case the file was removed from the testable files list
    // from the time it was submitted.
    if (db_affected_rows()) {
      drupal_set_message(t('%file has been submitted for re-testing -- results will be posted when testing completes.', array('%file' => $file_info->filename)));
    }
    else {
      drupal_set_message(t('Invalid file submitted.'), 'error');
    }
  }
  else {
    drupal_set_message(t('%file is not currently eligible for re-testing, and was not submitted.', array('%file' => $file_info->filename)), 'error');
  }

  $form_state['redirect'] = "node/$file_info->nid";
}

/**
 * Marks previously passed files for re-testing, if:
 *   1. The file's last test is older than the retest interval.
 *   2. The file is part of a project that's being tested.
 *   3. The file is attached to an issue that has one of the
 *      issue states marked for testing.
 *
 */
function pift_retest_check() {

  // Never re-test files.
  if (PIFT_RETEST_TIME == '-1') {
    return;
  }

  // Set up the retest time limit.
  $retest_time = time() - (PIFT_RETEST_TIME * 60 * 60);

  $where = '';
  $where_parts = array();
  $args = array(PIFT_RETEST, PIFT_PASSED, $retest_time);

  // Restrict to listed projects, if set.
  if ($projects = pift_project_list()) {
    $where_parts[] = ' p.nid IN ('. implode(',', array_fill(0, count($projects), '%d')) .')';
    $args = array_merge($args, $projects);
  }

  // Restrict to the status list, if set.
  if ($status_list = pift_status_list()) {
    $where_parts[] = 'pi.sid IN ('. implode(',', array_fill(0, count($status_list), '%d')) .')';
    $args = array_merge($args, $status_list);
  }

  // Add in release info if it exists.
  if (module_exists('project_release')) {
    // Restrict to release tag, if set.
    if ($release_tag_regex = variable_get('pift_release_tag_regex', '')) {
      $join = ' INNER JOIN {project_release_nodes} prn ON pi.rid = prn.nid';
      $where_parts[] = "prn.tag REGEXP '%s'";
      $args[] = $release_tag_regex;
    }
    else {
      $join = '';
    }
  }

  if (!empty($where_parts)) {
    $where .= " AND nid IN (SELECT pi.nid FROM {project_issues} pi INNER JOIN {node} p ON p.nid = pi.pid$join WHERE ". implode(' AND ', $where_parts) .")";
  }

  db_query("UPDATE {pift_data} SET status = %d WHERE status = %d AND timestamp < %d$where", $args);
}

/**
 * Sends file data to test servers, in a round robin approach.
 *
 * The files will be sent via XML-RPC to any servers listed on the settings page,
 * which also have a valid Project issue file review module installed and configured
 * with the server key of the PIFT server (available on the PIFT server settings page).
 *
 * The files will be sent in an array, each element of which is an associative array
 * with the following key/value pairs:
 *
 *     'ftid'          => The file test ID that was originally passed from
 *                       the test server for the file in question.
 *
 *     'cid'           => The comment ID of the comment the patch is
 *                        attached to.
 *
 *     'pid'           => The project ID.
 *
 *     'rid'           => The release ID.
 *
 *     'uid'           => The uid of the user who submitted the file.
 *
 *     'issue_id'      => nid of the issue.
 *
 *     'issue_title'   => Title of the issue.
 *
 *     'project'       => Project the patch is for.
 *
 *     'version'       => Project version string.
 *
 *     'tag'           => Release tag as found in {project_release_nodes}.
 *
 *     'submitter'     => Drupal user submitting the patch.
 *
 *     'patch_url'     => The absolute URL for the file.
 */
function pift_send_file_data() {
  global $base_url;

  // Get servers if any exist.
  if ($all_server_data = variable_get('pift_sites', '')) {
    $all_server_data = explode("\n", $all_server_data);
    $servers = array();
    $i = 0;

    // Set up the test servers.
    foreach ($all_server_data as $server_data) {
      if ($server_data) {
        // Set up the login data for the server. The test server needs
        // it's server key for authentication.
        $server_data = explode('@', $server_data);
        $server['server_key'] = $server_data[0];
        $server['xmlrpc_url'] = $server_data[1];
        // Basic testing to make sure the XML-RPC URL isn't totally bogus.
        if (preg_match('/^(http|https):\/\/.+\/xmlrpc.php/', $server['xmlrpc_url'])) {
          $i++;
          $servers[$i] = $server;
        }
        // Bad server URL.
        else {
          watchdog('project_remote', '%server is an invalid URL.', array('%server' => $server_xmlrpc_url), WATCHDOG_ERROR);
        }
      }
    }
    if (empty($servers)) {
      return;
    }
  }
  else {
    return;
  }

  // Set up the resend time limit.
  $resend_time = time() - (PIFT_RESEND_TIME * 60 * 60);
  $retest_time = time() - (PIFT_RETEST_TIME * 60 * 60);

  $where = '';
  $where_args = array();
  $sub_query_args = array(PIFT_UNTESTED, $resend_time, PIFT_RETEST, $retest_time, 0);

  // Restrict to listed projects, if set.
  if ($projects = pift_project_list()) {
    $where .= ' AND p.nid IN ('. implode(',', array_fill(0, count($projects), '%d')) .')';
    $where_args = array_merge($where_args, $projects);
  }

  // Restrict to the status list, if set.
  if ($status_list = pift_status_list()) {
    $where .= ' AND pi.sid IN ('. implode(',', array_fill(0, count($status_list), '%d')) .')';
    $where_args = array_merge($where_args, $status_list);
  }

  // Add in release info if it exists.
  if (module_exists('project_release')) {
    $select = ', prn.version, prn.tag';
    $join = ' LEFT JOIN {project_release_nodes} prn ON pi.rid = prn.nid';
    // Restrict to release tag, if set.
    if ($release_tag_regex = variable_get('pift_release_tag_regex', '')) {
      $where .= " AND prn.tag REGEXP '%s'";
      $where_args[] = $release_tag_regex;
    }
  }
  else {
    $select = '';
    $join = '';
  }

  // Assemble final args.
  $args = array_merge($sub_query_args, $where_args, $sub_query_args, $where_args);

  // Pull issue files that need to be sent for testing.  These include:
  // 1. All files marked as untested that have exceeded the resend period.
  //    since their last send (includes newly added files).
  // 2. All files that have been marked for re-testing.
  // This is one god awful query...  :(
  $files = db_query_range("(SELECT pd.ftid, pd.cid, n.nid AS issue_id, n.title AS issue_title, n.uid, pi.pid, pi.rid, f.filepath AS patch_url, p.title AS project, u.name AS submitter$select FROM {pift_data} pd INNER JOIN {project_issues} pi ON pd.nid = pi.nid INNER JOIN {files} f ON pd.fid = f.fid INNER JOIN {node} n ON n.nid = pi.nid INNER JOIN {node} p ON p.nid = pi.pid INNER JOIN {users} u ON u.uid = pd.uid$join WHERE ((pd.status = %d AND pd.timestamp < %d) OR (pd.status = %d AND pd.timestamp < %d)) AND pd.cid = %d$where) UNION (SELECT pd.ftid, pd.cid, n.nid AS issue_id, n.title AS issue_title, n.uid, pi.pid, pi.rid, f.filepath AS patch_url, p.title AS project, u.name AS submitter$select FROM {pift_data} pd INNER JOIN {project_issues} pi ON pd.nid = pi.nid INNER JOIN {files} f ON pd.fid = f.fid INNER JOIN {node} n ON n.nid = pi.nid INNER JOIN {node} p ON p.nid = pi.pid INNER JOIN {users} u ON u.uid = pd.uid$join WHERE ((pd.status = %d AND pd.timestamp < %d) OR (pd.status = %d AND pd.timestamp < %d)) AND pd.cid <> %d$where) ORDER BY ftid", $args, 0, PIFT_SEND_LIMIT);

  // Set up the batching variables.
  $bid = 0;
  $batches = array();
  $batch_total = 0;
  $sent_files = array();

  // Send new data if there is any.
  while ($file = db_fetch_array($files)) {
    if (is_readable($file['patch_url'])) {
      // Start the next batch if the current one is full.
      if ($batch_total >= PIFT_BATCH_SIZE) {
        $bid++;
        $batch_total = 0;
      }
      // Convert filepath to absolute URL.
      $file['patch_url'] = url($file['patch_url'], array('absolute' => TRUE));
      // Add the file to the current batch.
      $batches[$bid][] = $file;
      // Add to the list of files that will be sent with this batch.
      $sent_files[$bid][] = $file['ftid'];
      // Increment both the current batch size, and the total size.
      $batch_total++;
    }
    // File is not readable, mark as such.
    else {
      db_query("UPDATE {pift_data} SET status = %d WHERE ftid = %d", PIFT_NOT_READABLE, $file['ftid']);
    }
  }

  // Nothing to do.
  if (empty($batches)) {
    return;
  }

  $sent = array();

  // Get the next server in the round robin cycle.
  $s = variable_get('pift_next_test_server', 1);

  $server_key = pift_server_key();

  // Send batches, round robin.
  foreach ($batches as $bid => $batch) {
    // We're at the end of the server line, start over.
    if ($s > $i) {
      $s = 1;
    }
    // Send batch.
    $result = xmlrpc($servers[$s]['xmlrpc_url'], 'pifr.batch.queue', $server_key, $batch);

    // List of successful sends.
    if ($result == PIFR_RESPONSE_ACCEPTED) {
      // Update the last sent timestamp for this batch of files.
      db_query("UPDATE {pift_data} SET timestamp = %d WHERE ftid IN (". implode(', ', $sent_files[$bid]) .")", time());
      $sent[] = check_plain($servers[$s]['xmlrpc_url']) .' -- '. format_plural(count($sent_files[$bid]), '1 file sent', '@count files sent');
    }

    // Failed XML-RPC call.
    elseif ($result === FALSE) {
      pift_xmlrpc_error_handler($servers[$s]);
    }
    // Failed test server validation.
    else {
      pift_xmlrpc_error_handler($servers[$s], $result);
    }

    // Next server in line.
    $s++;
    variable_set('pift_next_test_server', $s);
  }

  // Record successful sends.
  if (!empty($sent)) {
    watchdog('project_remote', 'Project issue data sent successfully to the following servers:!servers', array('!servers' => theme('item_list', $sent)));
  }
}

/**
 * Implementation of hook_xmlrpc()
 */
function pift_xmlrpc() {
  return array(
    array(
      'pift.test.results',
      'pift_process_test_results',
      array('struct', 'struct', 'struct'),
      t('receive file test results from a test server')
    ),
  );
}

/**
 * Validates incoming test results and passes them along for processing.
 *
 * @param $server
 *   An associative array of login parameters, as follows:
 *     'url'        => The Full XML-RPC URL of the server sending the
 *                      data, ex. http://example.com/xmlrpc.php
 *     'server_key' => The server key for the server sending the data.
 *
 * @param $files
 *   An array of files to process. Each element an associative array
 *   of information for one file, as follows:
 *     'ftid'         => The file test ID that was originally passed to
 *                       the test server for the file in question.
 *
 *     'status'       => The file's test status (passed, failed, etc.).
 *
 *     'display_data' => Optional. A string of additional data to display
 *                       when rendering the file test results.
 *
 * @return
 *   An empty array if the test data was properly validated,
 *   otherwise an associative array with these key/value pairs:
 *     'error' => PIFT_XMLRPC_INVALID_SERVER | PIFT_XMLRPC_INVALID_SERVER_KEY
 */
function pift_process_test_results($server, $files) {
  // Build an array of valid test servers for this install.
  $test_servers = explode("\n", variable_get('pift_sites', ''));
  $valid_servers = array();
  foreach ($test_servers as $test_server) {
    if ($test_server) {
      $parts = explode('@', $test_server);
      $valid_servers[$parts[1]] = $parts[0];
    }
  }
  // Validate the test server URL against the list of valid test servers.
  if (isset($valid_servers[$server['url']])) {
    // Validate the server key for the test server.
    if ($valid_servers[$server['url']] == $server['server_key']) {
      pift_process_files($files);
      return array();
    }
    // Bad login.
    else {
      watchdog('project_remote', '%server attempted to send file test data, and has an invalid server key.', array('%server' => $server['url']), WATCHDOG_WARNING);
      return array('error' => 'PIFT_XMLRPC_INVALID_SERVER_KEY');
    }
  }
  // Bad test server.
  else {
    watchdog('project_remote', '%server attempted to send file test data, and is not on the valid server list.', array('%server' => $server['url']), WATCHDOG_WARNING);
    return array('error' => 'PIFT_XMLRPC_INVALID_SERVER');
  }
}

/**
 * Processing incoming file tests, and stores the results.
 *
 * @param $files
 *   An array of files to process. Each element an associative array
 *   of information for one file, as follows:
 *     'ftid'         => The file test ID that was originally passed to
 *                       the test server for the file in question.
 *
 *     'status'       => The file's test status (passed, failed, etc.).
 *
 *     'display_data' => Optional. A string of addition data to display
 *                       when rendering the file test results.
 */
function pift_process_files($files) {
  $ftids = array();
  $time = time();
  foreach ($files as $file) {
    // Discard the result data if the file isn't a testable file anymore.
    if ($nid = db_result(db_query("SELECT nid FROM {pift_data} WHERE ftid = %d", $file['ftid']))) {
      if (pift_check_issue_filters($nid)) {
        // Update the entry that was originally entered for this file,
        // and set the last tested timestamp to the current time.
        db_query("UPDATE {pift_data} SET display_data = '%s', status = %d, timestamp = %d WHERE ftid = %d", $file['display_data'], $file['status'], $time, $file['ftid']);
        $ftids[] = $file['ftid'];
        $file['issue_id'] = $nid;
        pift_check_auto_followup($file);
      }
      else {
        // File test result didn't pass filters, but still update the testing timestamp.
        db_query("UPDATE {pift_data} SET timestamp = %d WHERE ftid = %d", $time, $file['ftid']);
      }
    }
  }
}

/**
 * Checks an issue to see if it still passes testable file filters.
 *
 * @param $nid
 *   The issue node the file is attached to.
 */
function pift_check_issue_filters($nid) {

  $join = '';
  $where = '';
  $args = array($nid);
  return TRUE;

  // Restrict to listed projects, if set.
  if ($projects = pift_project_list()) {
    $where .= ' AND pi.pid IN ('. implode(',', array_fill(0, count($projects), '%d')) .')';
    $args = array_merge($args, $projects);
  }

  // Restrict to the status list, if set.
  if ($status_list = pift_status_list()) {
    $where .= ' AND pi.sid IN ('. implode(',', array_fill(0, count($status_list), '%d')) .')';
    $args = array_merge($args, $status_list);
  }

  // Restrict to release tag, if set.
  if (module_exists('project_release')) {
    if ($release_tag_regex = variable_get('pift_release_tag_regex', '')) {
      $join = ' LEFT JOIN {project_release_nodes} prn ON pi.rid = prn.nid';
      $where .= " AND prn.tag REGEXP '%s'";
      $args[] = $release_tag_regex;
    }
  }

  // Pull last testable file for the issue.
  $passed_filters = db_result(db_query("SELECT pi.nid FROM {project_issues} pi$join WHERE pi.nid = %d$where", $args));

  return $passed_filters;
}

/**
 * Checks a file to see if an auto status change is needed.
 *
 * Only files that have failed testing are eligible.  If the
 * auto followup sid is set, and the file failed testing, and the
 * file is the last testable file posted to the issue, then it
 * leaves a followup setting the issue sid to the auto followup
 * sid.
 *
 * @param $file
 *   An associative array of file test result information,
 *   with the following key/value pairs:
 *
 *     ftid     => The file test ID passed to the testing server.
 *     issue_id => The issue node the file is attached to.
 *     status   => The test result, should be on of the
 *                 constants PIFT_PASSED, PIFT_FAILED
 */
function pift_check_auto_followup($file) {

  // Only if an auto change followup sid is set, and only for failed files.
  if (variable_get('pift_auto_followup_sid', 0) && $file['status'] == PIFT_FAILED) {
    $join = '';
    $where = '';
    $args = array($file['issue_id']);

    // Restrict to listed projects, if set.
    if ($projects = pift_project_list()) {
      $where .= ' AND pi.pid IN ('. implode(',', array_fill(0, count($projects), '%d')) .')';
      $args = array_merge($args, $projects);
    }

    // Restrict to the status list, if set.
    if ($status_list = pift_status_list()) {
      $where .= ' AND pi.sid IN ('. implode(',', array_fill(0, count($status_list), '%d')) .')';
      $args = array_merge($args, $status_list);
    }

    // Restrict to release tag, if set.
    if (module_exists('project_release')) {
      if ($release_tag_regex = variable_get('pift_release_tag_regex', '')) {
        $join = ' LEFT JOIN {project_release_nodes} prn ON pi.rid = prn.nid';
        $where .= " AND prn.tag REGEXP '%s'";
        $args[] = $release_tag_regex;
      }
    }

    // Pull last testable file for the issue.
    $last_file = db_fetch_object(db_query_range("SELECT pd.ftid, pd.nid, pd.cid, pd.status FROM {pift_data} pd INNER JOIN {project_issues} pi ON pd.nid = pi.nid$join WHERE pd.nid = %d$where ORDER BY ftid DESC", $args, 0, 1));

    // There's an attached testable file on the issue, and
    // the file in question is the last file attached to the
    // issue.
    if ($last_file && $file['ftid'] == $last_file->ftid) {
      pift_auto_followup($last_file);
    }
  }
}

/**
 * Posts a followup to an issue.
 *
 * Sets the issue sid to the auto followup sid.
 *
 * @param $last_file
 *   A testable file object.
 */
function pift_auto_followup($last_file) {

  project_issue_add_followup(array(
    'nid' => $last_file->nid,
    'sid' => variable_get('pift_auto_followup_sid', 0),
    'comment' => theme('pift_auto_close_message', $last_file),
  ));
}

/**
 * Implementation of hook_nodeapi().
 */
function pift_nodeapi(&$node, $op, $arg) {
  if ($node->type == 'project_issue') {
    // Add attachments for this node to the send queue.
    if ($op == 'insert') {
      $files = upload_load($node);
      pift_add_issue_files($files);
    }
    // Only display test results for issue nodes when it's a full view.
    elseif (arg(0) == 'node' && is_numeric(arg(1))) {
      switch ($op) {
        case 'view':
          // Pull file attachments for this issue node.
          $result = db_query("SELECT f.filename, pd.ftid, pd.nid, pd.display_data, pd.status FROM {pift_data} pd INNER JOIN {files} f ON pd.fid = f.fid WHERE pd.nid = %d AND pd.cid = %d AND f.filepath <> '' AND pd.status <> %d ORDER BY ftid", $node->nid, 0, PIFT_UNTESTED);
          $display = array();

          // Load the files into an array to pass to the theming function.
          $retest = user_access('re-test files') && pift_check_issue_filters($node->nid);
          while ($file = db_fetch_array($result)) {
            $display[$file['ftid']] = array(
              'filename' => check_plain($file['filename']),
              'status' => $file['status'],
              'display_data' => filter_xss_admin($file['display_data']),  // Coming from a trusted server, relaxed filtering.
            );
          }
          // Display table just below file attachment.
          $node->content['file_test_data'] = array(
            '#value' => theme('pift_results', $display, $node->nid, 0, $retest),
            '#weight' => 51,  // Just below the upload attachments.
          );
          // Debug display.
          $debug_links = variable_get('pift_debug_file_testing_link', '');
          if ($debug_links) {
            $files = upload_load($node);
            $debug_test_links = array();
            foreach ($files as $file) {
              if (preg_match(PIFT_FILE_REGEX, $file->filename) && file_exists($file->filepath) && ($ftid = db_result(db_query("SELECT ftid FROM {pift_data} WHERE nid = %d AND cid = 0 AND fid = %d", $file->nid, $file->fid)))) {
                $file->ftid = $ftid;
                $debug_test_links[] = pift_build_file_testing_links($file);
              }
            }
          }
          if (!empty($debug_test_links)) {
            $node->content['file_test_debug_links'] = array(
              '#value' => theme('item_list', $debug_test_links),
              '#weight' => 52,  // Just below the upload attachments.
            );
          }
          break;
        case 'delete':
          // Remove related data in the test results table.
          db_query("DELETE FROM {pift_data} WHERE nid = %d", $node->nid);
          break;
        case 'update':
          // If files were deleted, remove related data in the test results table.
          if (is_array($node->files)) {
            foreach ($node->files as $file) {
              // Can be either an array or object as this point.
              $file = (object) $file;
              if ($file->remove) {
                db_query("DELETE FROM {pift_data} WHERE nid = %d AND fid = %d", $node->nid, $file->fid);
              }
            }
          }
          break;
      }
    }
  }
}

/**
 * Implementation of hook_user().
 */
function pift_user($type, $edit, &$user, $category = NULL) {
  if ($type == 'delete') {
    db_query("UPDATE {pift_data} SET uid = 0 WHERE uid = %d", $user->uid);
  }
}

/**
 * Implementation of hook_comment().
 */
function pift_comment(&$comment, $op) {
  static $cids = NULL;

  // $comment can be a comment object, or a form or form_values.
  if (is_object($comment)) {
    $nid = $comment->nid;
  }
  elseif (is_array($comment)) {
    $nid = is_array($comment['nid']) ? $comment['nid']['#value'] : $comment['nid'];
  }
  $node = node_load($nid);
  if ($node->type != 'project_issue') {
    return;
  }

  switch ($op) {
    case 'view':

      // To boost performance, cache the test results for all issue followups
      // at once, then grab the display data from the cache.
      if (!isset($cids)) {
        $cids = array();
        // Pull file attachments for all followups on the issue.
        $result = db_query("SELECT f.filename, cu.description, pd.ftid, pd.nid, pd.cid, pd.display_data, pd.status FROM {pift_data} pd INNER JOIN {comment_upload} cu ON pd.fid = cu.fid INNER JOIN {files} f ON pd.fid = f.fid WHERE pd.nid = %d AND pd.cid <> %d AND pd.status <> %d ORDER BY pd.ftid", $node->nid, 0, PIFT_UNTESTED);

        // Load the files into an array to pass to the theming function.
        $retest = user_access('re-test files') && pift_check_issue_filters($nid);
        while ($file = db_fetch_array($result)) {
          $cids[$file['cid']][$file['ftid']] = array(
            'filename' => check_plain($file['filename']),
            'description' => check_plain($file['description']),
            'status' => $file['status'],
            'display_data' => filter_xss_admin($file['display_data']),
          );
        }

        // Convert the results to themed display tables.
        foreach ($cids as $cid => $display) {
          $cids[$cid] = theme('pift_results', $display, $nid, $cid, $retest);
        }
      }

      // Add the test result display to the end of the comment.
      // TODO: When comment module's rendering isn't so whack,
      // always put this right after the attachment table.
      if (!empty($cids[$comment->cid])) {
        $comment->comment .= $cids[$comment->cid];
      }
      // Debug display.
      $debug_links = variable_get('pift_debug_file_testing_link', '');
      if ($debug_links) {
        $files = comment_upload_load_files($comment->cid);
        if (is_array($files)) {
          $debug_test_links = array();
          foreach ($files as $file) {
            // This blows, but comment_upload now stores files as arrays,
            // not objects, so cast here.
            $file = (object) $file;
            if (preg_match(PIFT_FILE_REGEX, $file->filename) && file_exists($file->filepath) && ($ftid = db_result(db_query("SELECT ftid FROM {pift_data} WHERE nid = %d AND cid = %d AND fid = %d", $file->nid, $file->cid, $file->fid)))) {
              $file->ftid = $ftid;
              $debug_test_links[] = pift_build_file_testing_links($file);
            }
          }
        }
        if (!empty($debug_test_links)) {
          $comment->comment .= theme('item_list', $debug_test_links);
        }
      }
      break;
    case 'insert':
      // Add attachments to this comment to the send queue.
      $files = comment_upload_load_files($comment['cid']);
      pift_add_followup_files($files);
      pift_check_followup_metadata($comment);
      break;
    case 'update':
      // If files were deleted, remove related data in the test results table.
      if (is_array($comment['files'])) {
        foreach ($comment['files'] as $file) {
          // Can be either an array or object as this point.
          $file = (object) $file;
          if ($file->remove) {
            db_query("DELETE FROM {pift_data} WHERE cid = %d AND fid = %d", $comment['cid'], $file->fid);
          }
        }
      }
      break;
    case 'delete':
      // Remove related data in the test results table.
      db_query("DELETE FROM {pift_data} WHERE cid = %d", $comment->cid);
      break;
  }
}

function pift_check_followup_metadata($comment) {

  $auto_followup_sid = variable_get('pift_auto_followup_sid', 0);

  // If no auto followup sid exists, then this check isn't necessary.
  if (!$auto_followup_sid) {
    return;
  }

  $projects = pift_project_list();
  $status_list = pift_status_list();
  $pid = $comment['project_info']['pid'];
  $sid = $comment['sid'];
  $rid = $comment['project_info']['rid'];
  $nid = $comment['nid'];
  $release_tag_regex = variable_get('pift_release_tag_regex', '');

  // Only proceed with checking if the current project and issue
  // status pass the filters. There's no easy way to check the
  // release tag filter here, so we'll check it when we pull the
  // last testable file.
  if ((empty($projects) || in_array($pid, $projects)) && (empty($status_list) || in_array($sid, $status_list))) {
    // We have to check to see if either pid, sid, or rid
    // has actually changed. There's no reliable way to do this
    // without querying {project_issue_comments} for it.
    $last_post = db_fetch_object(db_query_range("SELECT pid, sid, rid FROM {project_issue_comments} WHERE nid = %d AND cid <> %d ORDER BY cid DESC", $nid, $comment['cid'], 0, 1));
    // This comment being inserted is the first followup, so get
    // pid, sid, and rid from the issue itself.
    if (!$last_post) {
      $last_post = db_fetch_object(db_query("SELECT pid, sid, rid FROM {project_issues} WHERE nid = %d", $nid));
    }
    // A metadata change only matters if a filter is set, and
    // we need at least one piece of metadata to have changed.
    $metadata_change = (!empty($projects) && $last_post->pid != $pid) || (!empty($status_list) && $last_post->sid != $sid) || (!empty($release_tag_regex) && $last_post->rid != $rid);
    // Continue if there was a metadata change, except
    // in the special case where a user is trying to manually
    // set the issue state from the auto followup state to a testable
    // state, we want to allow this.
    if ($metadata_change && $last_post->sid != $auto_followup_sid) {
      $join = '';
      $where = '';
      $args = array($nid);
      // Restrict to release tag, if set.
      if (module_exists('project_release') && $release_tag_regex) {
        $join = ' INNER JOIN {project_issues} pi ON pd.nid = pi.nid LEFT JOIN {project_release_nodes} prn ON pi.rid = prn.nid';
        $where .= " AND prn.tag REGEXP '%s'";
        $args[] = $release_tag_regex;
      }

      // Pull last testable file for the issue.
      $last_file = db_fetch_object(db_query_range("SELECT pd.nid, pd.cid, pd.status FROM {pift_data} pd$join WHERE pd.nid = %d$where ORDER BY ftid DESC", $args, 0, 1));

      // There's an attached testable file on the issue, and
      // the last testable file has failed testing.
      if ($last_file && $last_file->status == PIFT_FAILED) {
        pift_auto_followup($last_file);
      }
    }
  }
}

/**
 * Theme test result data into a table.
 *
 * @param $results
 *   An array of test result data.
 * @param $nid
 *   The issue node ID.
 * @param $cid
 *   The comment ID (optional).
 * @param $retest
 *   Boolean indicating if a re-test link should be provided.
 * @return
 *   An HTML string of the rendered table.
 */
function theme_pift_results($results, $nid, $cid, $retest) {
  $rows = array();
  $output = '';

  // One row for each file test result.
  foreach ($results as $ftid => $result) {
    $description = !empty($result['description']) ? $result['description'] : $result['filename'];
    $retest_link = $retest ? ' - '. l(t('Request re-test'), "pift-server-request-retest/$nid/$cid/$ftid") : '';
    switch ($result['status']) {
      // File passed testing.
      case PIFT_PASSED:
        $rows[] = array(
          'data' => array(
            $description,
            t('passed') . $retest_link,
            $result['display_data'],  // Already filtered.
          ),
          'class' => 'pift-passed',
        );
        break;
      // File failed testing.
      case PIFT_FAILED:
        $rows[] = array(
          'data' => array(
            $description,
            t('failed') . $retest_link,
            $result['display_data'],  // Already filtered.
          ),
          'class' => 'pift-failed',
        );
        break;
      case PIFT_RETEST:
        $rows[] = array(
          'data' => array(
            $description,
            t('re-testing'),
            '',
          ),
          'class' => 'pift-retest',
        );
        break;
    }
  }

  // Only build the table if there are results to display.
  if (!empty($rows)) {
    $header = array(
      array(
        'data' => t('Testbed results'),
        'colspan' => '3',
      )
    );

    $id = "file-test-results-$nid";
    if (isset($cid)) {
      $id .= "-$cid";
    }

    $output = '<div id="'. $id .'" class="file-test-results">'. theme('table', $header, $rows) .'</div>';
  }

  return $output;
}

/**
 * Themes the comment posted on auto followups.
 *
 * @param $last_file
 *   A testable file object.
 */
function theme_pift_auto_close_message($last_file) {

  $output = '';
  $id = "#file-test-results-$last_file->nid";
  if ($last_file->cid) {
    $id .= "-$last_file->cid";
  }
  $output .= t('The last submitted patch <a href="@link">failed testing</a>.', array('@link' => $id));

  return $output;
}

/**
 * Records XML-RPC errors communicating to test servers.
 *
 * @param $server
 *   An associative array of server information, as follows:
 *     'user' => The user logging in.
 *     'xmlrpc_url' => The XML-RPC URL of the test server.
 *     'url'  => The Drupal base URL of the server sending the data.
 *
 * @param $error_code
 *   Optional. A string representing a validation error type.
 */
function pift_xmlrpc_error_handler($server, $error_code = NULL) {
  global $base_url;

  $t_args = array('%url' => $base_url, '%xmlrpc_url' => $server['xmlrpc_url']);

  switch ($error_code) {
    case PIFR_RESPONSE_INVALID_SERVER:
      watchdog('project_remote', 'Unable to log in %url to %xmlrpc_url -- invalid server key.', $t_args, WATCHDOG_ERROR);
      break;
    default:
      watchdog('project_remote', 'XML-RPC error communicating with %xmlrpc_url', $t_args, WATCHDOG_ERROR);
      break;
  }
}
