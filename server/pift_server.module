<?php
// $Id$
// $Name$

// File testing status definitions.
define('PIFT_UNTESTED', 0);
define('PIFT_PASSED', 1);
define('PIFT_FAILED', -1);
define('PIFT_NOT_READABLE', -2);

// Allow inclusion of some custom configuration.  Anything in the settings
// section below can be overridden by creating a variable with the same name
// as the define.
if (function_exists('drupal_get_path')) {
  $path = drupal_get_path('module', 'pift_server');
  if (file_exists("$path/pift_server.conf")) {
    include_once("$path/pift_server.conf");
  }
}

/**
 * Settings section
 */

// Limit on how many files to send for each cron run.
define('PIFT_SEND_LIMIT', isset($PIFT_SEND_LIMIT) ? $PIFT_SEND_LIMIT : 100);

// Number of files to send in a single call to a test server.
define('PIFT_BATCH_SIZE', isset($PIFT_BATCH_SIZE) ? $PIFT_BATCH_SIZE : 20);

// Regex for determining which file types should be sent for testing.
define('PIFT_FILE_REGEX', isset($PIFT_FILE_REGEX) ? $PIFT_FILE_REGEX : '/(\.diff|\.patch)$/');

// A comma separated list of project ID's (nids) that will be examined for
// new files. Leave empty for all projects.
define('PIFT_PROJECTS', isset($PIFT_PROJECTS) ? $PIFT_PROJECTS : '');

/**
 * End setting section.
 */

// Clean up -- don't want these floating around.
unset($PIFT_SEND_LIMIT, $PIFT_BATCH_SIZE, $PIFT_FILE_REGEX, $PIFT_PROJECTS);

/**
 * Implementation of hook_cron().
 */
function pift_server_cron() {
  $send = variable_get('pift_server_send_frequency', -1);
  // Check if sending is enabled.
  if ($send != -1) {
    $time = time();
    // Get time last sent.
    $last_sent = variable_get('pift_server_last_sent', time());
    $frequency = $send * 60;
    // Time to send again?
    if ($time > ($last_sent + $frequency)) {
      pift_server_add_new_files();
      pift_server_send_file_data();
      // Update last sent time.
      variable_set('pift_server_last_sent', $time);
    }
  }
}

/**
 * Implementation of hook_form_alter.
 */
function pift_server_form_alter($form_id, &$form) {
  global $user;
  switch ($form_id) {
    case 'project_issue_subscribe':
      // TODO: Would be nice to have this at the top of the form,
      // but the theming function for the form always puts it at
      // the bottom...  :(
      $form['pift_server_failed_test_mail_subscribe'] = array(
        '#type' => 'checkbox',
        '#title' => t('Receive notification of failed patch tests.'),
        '#default_value' => db_result(db_query("SELECT uid FROM {pift_subscriptions} WHERE uid = %d", $user->uid)),
        '#description' => t('Check here to receive e-mail notification when one of your posted patches fails regression testing.'),
        '#weight' => -10,
      );
      $form['#submit']['pift_server_failed_test_mail_subscribe_submit'] = array();
      break;
    case 'comment_form':
      $node = node_load($form['nid']['#value']);
      if ($node->type == 'project_issue') {
        // Add in custom description for file testing.
        if (isset($form['attachments']['wrapper']['new']['upload']) && pift_server_active_project($node->pid)) {
          $description = filter_xss_admin(variable_get('pift_server_file_description', ''));
          $form['attachments']['wrapper']['new']['upload']['#description'] .= $description;
        }
      }
      break;
    case 'project_issue_node_form':
      // Add in custom description for file testing.
      if (isset($form['project_info']['pid']['#default_value']) && pift_server_active_project($form['project_info']['pid']['#default_value'])) {
        $description = filter_xss_admin(variable_get('pift_server_file_description', ''));
        $form['issue_details']['file_issue']['#description'] .= $description;
      }
      break;
  }
}

/**
 * Submits the pift subscription setting for the current user.
 */
function pift_server_failed_test_mail_subscribe_submit($form_id, $form_values) {
  global $user;
  // Only insert a row if the checkbox is newly checked.
  if ($form_values['pift_server_failed_test_mail_subscribe']) {
    if (!db_result(db_query("SELECT uid FROM {pift_subscriptions} WHERE uid = %d", $user->uid))) {
      db_query("INSERT INTO {pift_subscriptions} (uid) VALUES (%d)", $user->uid);
    }
  }
  // Always remove if not checked.
  else {
    db_query("DELETE FROM {pift_subscriptions} WHERE uid = %d", $user->uid);
  }
}

/**
 * Implementation of hook_help().
 */
function pift_server_help($section) {
  switch ($section) {
    // Server settings page.
    case 'admin/project/project-issue-test-file-server':
      return t("
      <p>These settings configure the Project issue file test server module's remote communications to file test servers.</p>
      ");
      break;
  }
}

/**
 * Callback for the main settings page.
 */
function pift_server_settings_form() {

  $options = array(
    -1 => t('Disabled'),
    0 => t('Each cron run'),
    60 => t('Hourly'),
    1440 => t('Daily'),
    10080 => t('Weekly'),
    40320 => t('Monthly'),
  );

  $form['pift_server_send_frequency'] = array(
    '#type' => 'select',
    '#title' => t('Send frequency'),
    '#options' => $options,
    '#default_value' => variable_get('pift_server_send_frequency', -1),
    '#description' => t("How often new files should be sent to test servers."),
  );

  $form['pift_server_sites'] = array(
    '#type' => 'textarea',
    '#title' => t('Test sites'),
    '#default_value' => variable_get('pift_server_sites', ''),
    '#description' => t("List the login information and servers that will receive files for testing. Each site to receive information must have the <em>Project issue file test client</em> module installed, and you must include valid login information for a Drupal user on the test site who has the 'receive file test data' permission. Put one remote site per line, in the following format: <em>user::password::xmlrpc-url</em>. For example, <em>myusername::mypassword::http://example.com/xmlrpc.php</em>"),
  );

  $form['pift_server_file_description'] = array(
    '#type' => 'textarea',
    '#title' => t('Additional file description'),
    '#default_value' => variable_get('pift_server_file_description', ''),
    '#description' => t("Add text to the description of project issue file upload fields. Can by used to add clarification of files types, etc."),
  );

  $form['pift_failed_test_mail_text'] = array(
    '#type' => 'textarea',
    '#title' => t('Failed test e-mail'),
    '#default_value' => variable_get('pift_failed_test_mail_text', ''),
    '#description' => t("If a patch fails testing, and the user who wrote the patch is subscribed to receive notifications of test failures, an e-mail will be sent. Enter the body of the e-mail message above. Available tokens for the e-mail include: <em>!username, !site, !issue_title, !issue_url, !date, !reason, !filepath</em>. Leave blank to disable e-mail notifications."),
  );

  $form['pift_server_reset_send_queue'] = array(
    '#type' => 'checkbox',
    '#title' => t('Reset sending queue'),
    '#description' => t('If selected, the sending queue will be cleared, and only files submitted from the time of the reset will be sent.'),
  );

  // Custom submit handler
  $form['#submit']['pift_server_settings_form_extra_submit'] = array();
  // system_settings_form() doesn't add the default if #submit already exists.
  $form['#submit']['system_settings_form_submit'] = array();
  return system_settings_form($form);
}

/**
 * Handles extra submission tasks on the admin settings page.
 */
function pift_server_settings_form_extra_submit($form_id, $values) {
  global $form_values;

  // Reset the queue.
  if ($values['pift_server_reset_send_queue']) {
    pift_server_reset_send_queue();
    drupal_set_message(t('Send queue reset.'));
  }
  // Remove the setting so it's not saved to {variable}.
  unset($form_values['pift_server_reset_send_queue']);
}

/**
 * Implementation of hook_menu().
 */
function pift_server_menu($may_cache) {
  $items = array();

  if ($may_cache) {
    $access_admin = user_access('administer projects');
    // Admin settings page.
    $items[] = array(
      'path' => 'admin/project/project-issue-file-test-server',
      'title' => t('Project issue file test server settings'),
      'description' => t('Configure sending file tests to test servers.'),
      'callback' => 'drupal_get_form',
      'callback arguments' => array('pift_server_settings_form'),
      'access' => $access_admin,
      'type' => MENU_NORMAL_ITEM,
    );
  }
  else {
    // Include the CSS file for the file test results table, if we're at an issue node.
    if (arg(0) == 'node' && is_numeric(arg(1))) {
      $node = node_load(arg(1));
      if ($node->type == 'project_issue') {
        drupal_add_css(drupal_get_path('module', 'pift_server') .'/pift_server.css');
      }
    }
  }
  return $items;
}

/**
 * Gets the most recently processed issue and comment ID.
 *
 * @return
 *   An associative array of information, as follows:
 *     'issue'    => The most recently processed issue nid.
 *     'followup' => The most recently processed comment cid.
 */
function pift_server_get_last() {

  $last_issue = variable_get('pift_server_last_issue_processed', 0);
  $last_followup = variable_get('pift_server_last_followup_file_processed', 0);

  return array('issue' => $last_issue, 'followup' => $last_followup);
}

/**
 * Gets the newest issue and comment ID.
 *
 * @return
 *   An associative array of information, as follows:
 *     'issue'    => The most recent issue nid.
 *     'followup' => The most recent comment cid.
 */
function pift_server_get_newest() {

  $newest_issue = db_result(db_query("SELECT MAX(nid) FROM {node}"));
  // No result, set to zero.
  $newest_issue = $newest_issue === FALSE ? 0 : $newest_issue;

  $newest_followup_file = db_result(db_query("SELECT MAX(fid) FROM {comment_upload_files}"));
  // No result, set to zero.
  $newest_followup_file = $newest_followup_file === FALSE ? 0 : $newest_followup_file;

  return array('issue' => $newest_issue, 'followup' => $newest_followup_file);
}

/**
 * Sets the last processed issue/followup to the most
 * recently posted issue/followup, sets the last sent
 * time to the current time, and empties the send queue.
 */
function pift_server_reset_send_queue () {
  $newest = pift_server_get_newest();
  variable_set('pift_server_last_issue_processed', $newest['issue']);
  variable_set('pift_server_last_followup_file_processed', $newest['followup']);
  variable_set('pift_server_last_sent', time());
  // Remove all untested files.
  // TODO: Do we really want to do this??
  db_query("DELETE FROM {pift_data} WHERE status = %d", PIFT_UNTESTED);
}

/**
 * Adds newly submitted issues/folowups to the send queue.
 */
function pift_server_add_new_files() {
  global $base_url;

  // Pull both the last items processed, and the newest items submitted.
  // This is the range that we can enter into the queue during this run.
  $last = pift_server_get_last();
  $newest = pift_server_get_newest();
  $data['issues'] = array();
  $data['followups'] = array();

  // Pull all new issue data. Limit the results to PIFT_SEND_LIMIT for consistency.
  $issues = db_query_range("SELECT n.nid, n.uid, pi.file_path FROM {node} n INNER JOIN {project_issues} pi ON n.nid = pi.nid WHERE n.type = 'project_issue' AND n.nid > %d AND n.nid <= %d AND pi.file_path <> '' ORDER BY n.nid", $last['issue'], $newest['issue'], 0, PIFT_SEND_LIMIT);

  while ($issue = db_fetch_object($issues)) {
    // Update last processed here, in case the server dies during the run.
    variable_set('pift_server_last_issue_processed', $issue->nid);

    // Put the file data into the send queue.
    if (preg_match(PIFT_FILE_REGEX, basename($issue->file_path)) && file_exists($issue->file_path)) {
      $ftid = db_next_id('{pift_data}_ftid');
      db_query("INSERT INTO {pift_data} (ftid, fid, nid, cid, uid, display_data, status) VALUES (%d, %d, %d, %d, %d, '%s', %d)", $ftid, 0, $issue->nid, 0, $issue->uid, '', PIFT_UNTESTED);
    }
  }

  // Pull all new followup file data. Limit the results to PIFT_SEND_LIMIT for consistency.
  $followup_files = db_query_range("SELECT n.nid, c.cid, c.uid, cu.fid, cu.filepath FROM {node} n INNER JOIN {comments} c ON n.nid = c.nid INNER JOIN {comment_upload_files} cu ON c.cid = cu.cid WHERE n.type = 'project_issue' AND cu.fid > %d AND cu.fid <= %d AND cu.filepath <> '' ORDER BY c.cid, cu.fid", $last['followup'], $newest['followup'], 0, PIFT_SEND_LIMIT);

  while ($followup_file = db_fetch_object($followup_files)) {
    // Update last processed here, in case the server dies during the run.
    variable_set('pift_server_last_followup_file_processed', $followup_file->fid);

    // Put the file data into the send queue.
    if (preg_match(PIFT_FILE_REGEX, basename($followup_file->filepath)) && file_exists($followup_file->filepath)) {
      $ftid = db_next_id('{pift_data}_ftid');
      db_query("INSERT INTO {pift_data} (ftid, fid, nid, cid, uid, display_data, status) VALUES (%d, %d, %d, %d, %d, '%s', %d)", $ftid, $followup_file->fid, $followup_file->nid, $followup_file->cid, $followup_file->uid, '', PIFT_UNTESTED);
    }
  }
}

/**
 * Sends file data to test servers, in a round robin approach.
 */
function pift_server_send_file_data() {
  global $base_url;

  // Get servers if any exist.
  if ($all_server_data = variable_get('pift_server_sites', '')) {
    $all_server_data = explode("\n", $all_server_data);
  }
  else {
    return;
  }

  // Add in release info if it exists.
  if (module_exists('project_release')) {
    $select = ', prn.version';
    $join = ' LEFT JOIN {project_release_nodes} prn ON pi.rid = prn.nid';
  }
  else {
    $select = '';
    $join = '';
  }

  // Restrict to listed projects, if set.
  if (PIFT_PROJECTS) {
    $projects = array_filter(explode(',', PIFT_PROJECTS), 'is_numeric');
    $where = ' AND p.nid IN ('. implode(', ', $projects) .')';
  }
  else {
    $where = '';
  }

  // Pull all issue files that haven't yet received test results.
  // This is one god awful query...  :(
  $files = db_query("(SELECT pd.ftid, n.nid AS issue_id, n.title AS issue_title, n.uid, pi.pid, pi.rid, pi.file_path AS patch_url, p.title AS project, u.name AS submitter$select FROM {pift_data} pd INNER JOIN {project_issues} pi ON pd.nid = pi.nid INNER JOIN {node} n ON n.nid = pi.nid INNER JOIN {node} p ON p.nid = pi.pid INNER JOIN {users} u ON u.uid = n.uid$join WHERE pd.status = %d AND pd.cid = %d$where) UNION (SELECT pd.ftid, n.nid AS issue_id, n.title AS issue_title, n.uid, pi.pid, pi.rid, cu.filepath AS patch_url, p.title AS project, u.name AS submitter$select FROM {pift_data} pd INNER JOIN {project_issues} pi ON pd.nid = pi.nid INNER JOIN {comment_upload_files} cu ON pd.fid = cu.fid INNER JOIN {node} n ON n.nid = pi.nid INNER JOIN {node} p ON p.nid = pi.pid INNER JOIN {users} u ON u.uid = n.uid$join WHERE pd.status = %d AND pd.cid <> %d$where) ORDER BY ftid", PIFT_UNTESTED, 0, PIFT_UNTESTED, 0);

  // Set up the batching variables.
  $bid = 0;
  $batches = array();
  $batch_total = 0;
  $total = 0;

  // Send new data if there is any.
  while (($file = db_fetch_array($files)) && $total <= PIFT_SEND_LIMIT) {
    if (is_readable($file['patch_url'])) {
      // Start the next batch if the current one is full.
      if ($batch_total >= PIFT_BATCH_SIZE) {
        $bid++;
        $batch_total = 0;
      }
      // Convert filepath to absolute URL.
      $file['patch_url'] = url($file['patch_url'], NULL, NULL, TRUE);
      // Add the file to the current batch.
      $batches[$bid][] = $file;
      // Increment both the current batch size, and the total size.
      $batch_total++;
      $total++;
    }
    // File is not readable, mark as such.
    else {
      db_query("UPDATE {pift_data} SET status = %d WHERE ftid = %d", PIFT_NOT_READABLE, $file['ftid']);
    }
  }

  $servers = array();
  $i = 0;

  // Set up the test servers.
  foreach ($all_server_data as $server_data) {
    if ($server_data) {
      // Set up the login data for the server. The test server needs
      // a username, password, and the base URL of the sending server.
      $server_data = explode('::', $server_data);
      $server['user'] = $server_data[0];
      $server['pass'] = $server_data[1];
      $server['url'] = $base_url .'/xmlrpc.php';
      $server['xmlrpc_url'] = $server_data[2];
      // Basic testing to make sure the XML-RPC URL isn't totally bogus.
      if (preg_match('/^(http|https):\/\/.+\/xmlrpc.php/', $server['xmlrpc_url'])) {
        $i++;
        $servers[$i] = $server;
      }
      // Bad server URL.
      else {
        watchdog('project_remote', t('%server is an invalid URL.', array('%server' => $server_xmlrpc_url)), WATCHDOG_ERROR);
      }
    }
  }

  $sent = array();

  // Get the next server in the round robin cycle.
  $s = variable_get('pift_next_test_server', 1);

  // Send batches, round robin.
  foreach ($batches as $batch) {
    // We're at the end of the server line, start over.
    if ($s > $i) {
      $s = 1;
    }
    // Send batch.
    $result = xmlrpc($servers[$s]['xmlrpc_url'], 'pift.test.files', $servers[$s], $batch);

    // Failed XML-RPC call.
    if ($result === FALSE) {
      pift_server_xmlrpc_error_handler($servers[$s]);
    }
    // Failed test server validation.
    elseif (isset($result['error'])) {
      pift_server_xmlrpc_error_handler($servers[$s], $result['error']);
    }
    // List of successful sends.
    else {
      $sent[] = check_plain($servers[$s]['xmlrpc_url']);
    }
    // Next server in line.
    $s++;
    variable_set('pift_next_test_server', $s);
  }

  // Record successful sends.
  if (!empty($sent)) {
    watchdog('project_remote', t('Project issue data sent successfully to the following servers:!servers', array('!servers' => theme('item_list', $sent))));
  }
}

/**
 * Ensure that the given user has permission to return file test results.
 */
function pift_server_validate_user($username, $password) {
  global $user;

  $user = user_authenticate($username, $password);

  if ($user->uid) {
    if (user_access('administer projects', $user)) {
      return $user;
    }
  }

  return FALSE;
}

/**
 * Implementation of hook_xmlrpc()
 */
function pift_server_xmlrpc() {
  return array(
    array(
      'pift.test.results',
      'pift_server_process_test_results',
      array('boolean', 'struct', 'struct'),
      t('receive file test results from a test server')
    ),
  );
}

/**
 * Validates incoming test results and passes them along for processing.
 *
 * @param $server
 *   An associative array of login parameters, as follows:
 *     'user' => The username to log in.
 *     'pass' => The user's password.
 *     'url'  => The Drupal base URL of the server sending the data.
 *
 * @param $files
 *   An array of files to process. Each element an associative array
 *   of information for one file, as follows:
 *     'ftid'         => The file test ID that was originally passed to
 *                       the test server for the file in question.
 *
 *     'status'       => The file's test status (passed, failed, etc.).
 *
 *     'display_data' => Optional. A string of additional data to display
 *                       when rendering the file test results.
 *
 * @return
 *   TRUE if the test data was properly validated, FALSE otherwise.
 */
function pift_server_process_test_results($server, $files) {
  // Build an array of valid test servers for this install.
  $test_servers = explode("\n", variable_get('pift_server_sites', ''));
  $valid_servers = array();
  foreach ($test_servers as $test_server) {
    if ($test_server) {
      $parts = explode('::', $test_server);
      $valid_servers[] = $parts[2];
    }
  }
  // Validate the test server URL against the list of valid test servers.
  if (in_array($server['url'], $valid_servers)) {
    // Validate the user submitting the test results.
    if (pift_server_validate_user($server['user'], $server['pass'])) {
      pift_server_process_files($files);
      return array();
    }
    // Bad login.
    else {
      watchdog('project_remote', t('Invalid user %user tried to send project issue file test data.', array('%user' => $server['user'])), WATCHDOG_WARNING);
      return array('error' => 'PIFT_XMLRPC_INVALID_USER');
    }
  }
  // Bad test server.
  else {
    watchdog('project_remote', t('%server attempted to file test data, and is not on the valid server list.', array('%server' => $server['url'])), WATCHDOG_WARNING);
    return array('error' => 'PIFT_XMLRPC_INVALID_SERVER');
  }
}

/**
 * Processing incoming file tests, and stores the results.
 *
 * @param $files
 *   An array of files to process. Each element an associative array
 *   of information for one file, as follows:
 *     'ftid'         => The file test ID that was originally passed to
 *                       the test server for the file in question.
 *
 *     'status'       => The file's test status (passed, failed, etc.).
 *
 *     'display_data' => Optional. A string of addition data to display
 *                       when rendering the file test results.
 */
function pift_server_process_files($files) {
  $ftids = array();
  foreach ($files as $file) {
    // Update the entry that was originally entered for this file.
    db_query("UPDATE {pift_data} SET display_data = '%s', status = %d WHERE ftid = %d", $file['display_data'], $file['status'], $file['ftid']);
    $ftids[] = $file['ftid'];
  }
  pift_server_mail_failed_tests($ftids);
}

/**
 * E-mails subscribed users when their file fails regression testing.
 *
 * @param $ftids
 *   An array of file test ID's to check for failure.
 */
function pift_server_mail_failed_tests($ftids) {
  // E-mail functionality is disabled.
  if (!($mail_text = variable_get('pift_failed_test_mail_text', ''))) {
    return;
  }

  // Filter out bad/risky data.
  $ftids = array_filter($ftids, 'is_numeric');
  if (!empty($ftids)) {
    $site_name = variable_get('site_name', 'Drupal');

    // Pull only the file data for files that have failed, and that
    // relate to a use that's subscribe to receive test failure emails.
    $issue_emails = db_query("SELECT u.name, u.mail, n.title, pd.fid, pd.nid, pd.cid, pd.display_data FROM {pift_data} pd INNER JOIN {node} n ON n.nid = pd.nid INNER JOIN {pift_subscriptions} ps ON pd.uid = ps.uid INNER JOIN {users} u ON u.uid = pd.uid WHERE n.status = 1 AND u.status = 1 AND pd.ftid IN (". implode(', ', $ftids) .") AND pd.status = %d", PIFT_FAILED);

    while ($mail = db_fetch_object($issue_emails)) {

      // Pull the filepath here, since we can't get it from the query above --
      // it could be coming from two different places. Send user directly to
      // the comment if the file was attached to a comment.
      if ($mail->cid) {
        $filepath = db_result(db_query("SELECT filepath FROM {comment_upload_files} WHERE fid = %d", $mail->fid));
        $fragment = "comment-$mail->cid";
      }
      else {
        $filepath = db_result(db_query("SELECT file_path FROM {project_issues} WHERE nid = %d", $mail->nid));
        $fragment = NULL;
      }

      if (file_exists($filepath)) {
        $variables = array(
          '!username' => $mail->name,
          '!site' => $site_name,
          '!issue_title' => $mail->title,
          '!issue_url' => url('node/'. $mail->nid, NULL, $fragment, TRUE),
          '!date' => format_date(time()),
          '!reason' => $mail->display_data,
          '!filepath' => url($filepath, NULL, NULL, TRUE),
        );

        $body = strtr($mail_text, $variables);
        $subject = t('!site Testbed server', array('!site' => $site_name));
        drupal_mail('pift_failed_test', $mail->mail, $subject, $body);
      }
    }
  }
}

/**
 * Implementation of hook_nodeapi().
 */
function pift_server_nodeapi(&$node, $op, $arg) {
  // Only display test results for issue nodes when it's a full view.
  if ($node->type == 'project_issue' && arg(0) == 'node' && is_numeric(arg(1))) {
    switch ($op) {
      case 'view':
        // Pull file attachments for this issue node.
        $result = db_query("SELECT pi.file_path AS filepath, pd.display_data, pd.status FROM {pift_data} pd INNER JOIN {project_issues} pi ON pi.nid = pd.nid WHERE pi.nid = %d AND pd.cid = %d AND pi.file_path <> '' AND pd.status <> %d ORDER BY ftid", $node->nid, 0, PIFT_UNTESTED);
        $display = array();

        // Load the files into an array to pass to the theming function.
        while ($file = db_fetch_array($result)) {
          $display[] = array(
            'filepath' => $file['filepath'],
            'status' => $file['status'],
            'display_data' => filter_xss_admin($file['display_data']),  // Coming from a trusted server, relaxed filtering.
          );
        }
        // Display table just below file attachment.
        // TODO: this should move in the future when the attachment location
        // gets moved from the metadata table.
        $node->content['file_test_data'] = array(
          '#value' => theme('pift_server_results', $display),
          '#weight' => -4,
        );
        break;
      case 'delete':
        // Remove related data in the test results table.
        db_query("DELETE FROM {pift_data} WHERE nid = %d", $node->nid);
        break;
    }
  }
}

/**
 * Implementation of hook_user().
 */
function pift_server_user($type, $edit, &$user, $category = NULL) {
  if ($type == 'delete') {
    db_query("DELETE FROM {pift_subscriptions} WHERE uid = %d", $user->uid);
    db_query("UPDATE {pift_data} SET uid = 0 WHERE uid = %d", $user->uid);
  }
}

/**
 * Implementation of hook_comment().
 */
function pift_server_comment(&$comment, $op) {
  static $cids = NULL;

  // $comment can be a comment object, or a form or form_values.
  if (is_object($comment)) {
    $nid = $comment->nid;
  }
  elseif (is_array($comment)) {
    $nid = is_array($comment['nid']) ? $comment['nid']['#value'] : $comment['nid'];
  }
  $node = node_load($nid);
  if ($node->type != 'project_issue') {
    return;
  }

  switch ($op) {
    case 'view':

      // To boost performance, cache the test results for all issue followups
      // at once, then grab the display data from the cache.
      if (!isset($cids)) {
        $cids = array();
        // Pull file attachments for all followups on the issue.
        $result = db_query("SELECT cu.cid, cu.filepath, cu.description, pd.display_data, pd.status FROM {pift_data} pd INNER JOIN {comment_upload_files} cu ON pd.fid = cu.fid WHERE cu.nid = %d AND pd.cid <> %d AND status <> %d ORDER BY ftid", $node->nid, 0, PIFT_UNTESTED);

        // Load the files into an array to pass to the theming function.
        while ($file = db_fetch_array($result)) {
          $cids[$file['cid']][] = array(
            'filepath' => $file['filepath'],
            'description' => $file['description'],
            'status' => $file['status'],
            'display_data' => filter_xss_admin($file['display_data']),
          );
        }

        // Convert the results to themed display tables.
        foreach ($cids as $cid => $display) {
          $cids[$cid] = theme('pift_server_results', $display);
        }
      }

      // Add the test result display to the end of the comment.
      // TODO: When comment module's rendering isn't so whack,
      // always put this right after the attachment table.
      if (!empty($cids[$comment->cid])) {
        $comment->comment .= $cids[$comment->cid];
      }
      break;
    case 'update':
      // Remove related data in the test results table.
      foreach ($comment['files'] as $file) {
        $file = (object)$file;
        if ($file->remove) {
          db_query("DELETE FROM {pift_data} WHERE cid = %d AND fid = %d", $comment['cid'], $file->fid);
        }
      }
      break;
    case 'delete':
      // Remove related data in the test results table.
      db_query("DELETE FROM {pift_data} WHERE cid = %d", $comment->cid);
      break;
  }
}

/**
 * Theme test result data into a table.
 *
 * @param $results
 *   An array of test result data.
 * @return
 *   An HTML string of the rendered table.
 */
function theme_pift_server_results($results) {
  $rows = array();
  $output = '';

  // One row for each file test result.
  foreach ($results as $result) {
    $description = $result['description'] ? $result['description'] : basename($result['filepath']);
    switch ($result['status']) {
      // File passed testing.
      case PIFT_PASSED:
        $rows[] = array(
          'data' => array(
            $description,
            t('passed'),
            $result['display_data'],
          ),
          'class' => 'pift-passed',
        );
        break;
      // File failed testing.
      case PIFT_FAILED:
        $rows[] = array(
          'data' => array(
            $description,
            t('failed'),
            $result['display_data'],
          ),
          'class' => 'pift-failed',
        );
        break;
    }
  }

  // Only build the table if there are results to display.
  if (!empty($rows)) {
    $header = array(
      array(
        'data' => t('Testbed results'),
        'colspan' => '3',
      )
    );
    $output = '<div class="file-test-results">'. theme('table', $header, $rows) .'</div>';
  }

  return $output;
}

/**
 * Records XML-RPC errors communicating to test servers.
 *
 * @param $server
 *   An associative array of server information, as follows:
 *     'user' => The user logging in.
 *     'xmlrpc_url' => The XML-RPC URL of the test server.
 *     'url'  => The Drupal base URL of the server sending the data.
 *
 * @param $error_code
 *   Optional. A string representing a validation error type.
 */
function pift_server_xmlrpc_error_handler($server, $error_code = NULL) {
  global $base_url;

  $t_args = array('%url' => $base_url, '%xmlrpc_url' => $server['xmlrpc_url'], '%user' => $server['user']);

  switch($error_code) {
    case 'PIFT_XMLRPC_INVALID_SERVER':
      watchdog('project_remote', t('%url is not listed as a valid project server at test server %xmlrpc_url', $t_args), WATCHDOG_ERROR);
      break;
    case 'PIFT_XMLRPC_INVALID_USER':
      watchdog('project_remote', t('Unable to log in %url to %xmlrpc_url using user %user, due to invalid login credentials or insufficient user permissions.', $t_args), WATCHDOG_ERROR);
      break;
    default:
      watchdog('project_remote', t('XML-RPC error communicating with %xmlrpc_url', $t_args), WATCHDOG_ERROR);
      break;
  }
}

/**
 * Checks to see if the project is currently being monitored by
 * pift_s for file testing.
 *
 * @param $pid
 *   The project nid.
 * @return
 *   TRUE if the project is in the active project list, or if the list
 *   is empty.  FALSE otherwise.
 */
function pift_server_active_project($pid) {
  if ($projects = PIFT_PROJECTS) {
    $projects = explode(',', $projects);
    $projects = array_map('trim', $projects);
    return in_array($pid, $projects);
  }
  else {
    return TRUE;
  }
}
