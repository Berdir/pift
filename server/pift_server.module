<?php
// $Id$

/**
 * Advanced settings section
 */
// Limit on how many files to send for each cron run.
define('PIFT_SEND_LIMIT', variable_get('pift_send_limit', 100));
// Number of files to send in a single call to a test server.
define('PIFT_BATCH_SIZE', variable_get('pift_batch_size', 20));
// Regex for determining which file types should be sent for testing.
define('PIFT_FILE_REGEX', variable_get('pift_file_regex', '/(\.diff|\.patch)$/'));
// Number of hours to wait before resending an untested file to a test
// server (ie, the test server never sent back the results).
define('PIFT_RESEND_TIME', variable_get('pift_resend_time', 2));
// Number of hours to wait before retesting a previously passes file.
define('PIFT_RETEST_TIME', variable_get('pift_retest_time', 24));

// File testing status definitions.
define('PIFT_UNTESTED', 0);
define('PIFT_PASSED', 1);
define('PIFT_FAILED', 2);
define('PIFT_RETEST', 3);
define('PIFT_NOT_READABLE', 4);

/**
 * Implementation of hook_cron().
 */
function pift_server_cron() {
  $send = variable_get('pift_server_send_frequency', -1);
  // Check if sending is enabled.
  if ($send != -1) {
    $time = time();
    // Get time last sent.
    $last_sent = variable_get('pift_server_last_sent', time());
    $frequency = $send * 60;
    // Time to send again?
    if ($time > ($last_sent + $frequency)) {
      pift_server_retest_check();
      pift_server_send_file_data();
      // Update last sent time.
      variable_set('pift_server_last_sent', $time);
    }
  }
}

/**
 * Implementation of hook_form_alter.
 */
function pift_server_form_alter($form_id, &$form) {
  global $user;
  switch ($form_id) {
    case 'project_issue_subscribe':
      // TODO: Would be nice to have this at the top of the form,
      // but the theming function for the form always puts it at
      // the bottom...  :(
      $form['pift_server_failed_test_mail_subscribe'] = array(
        '#type' => 'checkbox',
        '#title' => t('Receive notification of failed patch tests.'),
        '#default_value' => db_result(db_query("SELECT uid FROM {pift_subscriptions} WHERE uid = %d", $user->uid)),
        '#description' => t('Check here to receive e-mail notification when one of your posted patches fails regression testing.'),
        '#weight' => -10,
      );
      $form['#submit']['pift_server_failed_test_mail_subscribe_submit'] = array();
      break;
    case 'comment_form':
      $node = node_load($form['nid']['#value']);
      if ($node->type == 'project_issue') {
        // Add in custom description for file testing.
        if (isset($form['attachments']['wrapper']['new']['upload']) && pift_server_active_project($node->pid)) {
          $description = filter_xss_admin(variable_get('pift_server_file_description', ''));
          $form['attachments']['wrapper']['new']['upload']['#description'] .= $description;
        }
      }
      break;
    case 'project_issue_node_form':
      // Add in custom description for file testing, test here for the existence of a project,
      // so the description doesn't get added to page 1 of the new issue form.
      if (isset($form['project_info']['pid']['#default_value']) && isset($form['attachments']['wrapper']['new']['upload']) && pift_server_active_project($form['project_info']['pid']['#default_value'])) {
        $description = filter_xss_admin(variable_get('pift_server_file_description', ''));
        $form['attachments']['wrapper']['new']['upload']['#description'] .= $description;
      }
      break;
  }
}

/**
 * Implementation of hook_perm().
 */
function pift_server_perm() {
  return array('re-test files');
}

/**
 * Submits the pift subscription setting for the current user.
 */
function pift_server_failed_test_mail_subscribe_submit($form_id, $form_values) {
  global $user;
  // Only insert a row if the checkbox is newly checked.
  if ($form_values['pift_server_failed_test_mail_subscribe']) {
    if (!db_result(db_query("SELECT uid FROM {pift_subscriptions} WHERE uid = %d", $user->uid))) {
      db_query("INSERT INTO {pift_subscriptions} (uid) VALUES (%d)", $user->uid);
    }
  }
  // Always remove if not checked.
  else {
    db_query("DELETE FROM {pift_subscriptions} WHERE uid = %d", $user->uid);
  }
}

/**
 * Implementation of hook_help().
 */
function pift_server_help($section) {
  switch ($section) {
    // Server settings page.
    case 'admin/project/project-issue-test-file-server':
      return t("
      <p>These settings configure the Project issue file test server module's remote communications to file test servers.</p>
      ");
      break;
  }
}

/**
 * Callback for the main settings page.
 */
function pift_server_settings_form() {

  $options = array(
    -1 => t('Disabled'),
    0 => t('Each cron run'),
    60 => t('Hourly'),
    1440 => t('Daily'),
    10080 => t('Weekly'),
    40320 => t('Monthly'),
  );

  $form['pift_server_send_frequency'] = array(
    '#type' => 'select',
    '#title' => t('Send frequency'),
    '#options' => $options,
    '#default_value' => variable_get('pift_server_send_frequency', -1),
    '#description' => t("How often new files should be sent to test servers."),
  );

  // Warn about node access and login security issues.
  $form['pift_server_access_warning'] = array(
    '#prefix' => '<div class="pift-server-warning">',
    '#suffix' => '</div>',
    '#value' => t('IMPORTANT:<p>The file test server does not perform node access checks related to the sending of file testing information. Only trust test servers that you have control over, as they are getting access to node information related to any file test sent, regardless of any node access control you impose on your site.</p><p>Keep all server keys listed below confidential.</p>')
  );

  $form['pift_server_server_key'] = array(
    '#type' => 'item',
    '#title' => t('Server key'),
    '#value' => pift_server_server_key(),
    '#description' => t("This key must be entered in the <em>Project issue file review</em> settings on any test server you wish to send files to."),
  );

  $form['pift_server_sites'] = array(
    '#type' => 'textarea',
    '#title' => t('Test sites'),
    '#default_value' => variable_get('pift_server_sites', ''),
    '#description' => t("List the login information and servers that will receive files for testing. Each site to receive information must have the <em>Project issue file review</em> module installed, and you must include the remote server's private key. Put one remote site per line, in the following format: <em>key@xmlrpc-url</em>. For example, <em>testserversecretkey@http://example.com/xmlrpc.php</em>"),
  );

  $form['pift_server_file_description'] = array(
    '#type' => 'textarea',
    '#title' => t('Additional file description'),
    '#default_value' => variable_get('pift_server_file_description', ''),
    '#description' => t("Add text to the description of project issue file upload fields. Can by used to add clarification of files types, etc."),
  );

  $form['pift_failed_test_mail_text'] = array(
    '#type' => 'textarea',
    '#title' => t('Failed test e-mail'),
    '#default_value' => variable_get('pift_failed_test_mail_text', ''),
    '#description' => t("If a patch fails testing, and the user who wrote the patch is subscribed to receive notifications of test failures, an e-mail will be sent. Enter the body of the e-mail message above. Available tokens for the e-mail include: <em>!username, !site, !issue_title, !issue_url, !date, !reason, !filepath</em>. Leave blank to disable e-mail notifications."),
  );

  $form['pift_server_debug_file_testing_link'] = array(
    '#type' => 'checkbox',
    '#title' => t('Include debug file testing links'),
    '#default_value' => variable_get('pift_server_debug_file_testing_link', ''),
    '#description' => t('If selected, a user message will be displayed after each testable patch is submitted, containing links to manually submit a pass/fail test result for the file.'),
  );

  $form['pift_server_reset_send_queue'] = array(
    '#type' => 'checkbox',
    '#title' => t('Reset sending queue'),
    '#description' => t('If selected, the sending queue will be cleared, and only files submitted from the time of the reset will be sent.'),
  );

  $form['advanced'] = array(
    '#type' => 'fieldset',
    '#title' => t('Advanced settings'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );

  $form['advanced']['pift_send_limit'] = array(
    '#type' => 'textfield',
    '#title' => t('Send limit'),
    '#description' => t('Limit on how many files to send for each cron run. Default is 100.'),
    '#required' => TRUE,
    '#default_value' => variable_get('pift_send_limit', 100),
    '#size' => 10,
    '#maxlength' => 10,
    '#validate' => array('pift_server_is_numeric_validate' => array()),
  );

  $form['advanced']['pift_batch_size'] = array(
    '#type' => 'textfield',
    '#title' => t('Batch size'),
    '#description' => t('Number of files to send in a single call to a test server. Default is 20.'),
    '#required' => TRUE,
    '#default_value' => variable_get('pift_batch_size', 20),
    '#size' => 10,
    '#maxlength' => 10,
    '#validate' => array('pift_server_is_numeric_validate' => array()),
  );

  $form['advanced']['pift_file_regex'] = array(
    '#type' => 'textfield',
    '#title' => t('File regex'),
    '#description' => t('Regex for determining which file types should be sent for testing. Default is all files ending in <em>.patch</em> or <em>.diff</em>. You must include the full regex, ex. <em>/(\.diff|\.patch)$/</em>'),
    '#required' => TRUE,
    '#default_value' => variable_get('pift_file_regex', '/(\.diff|\.patch)$/'),
  );

  $form['advanced']['pift_resend_time'] = array(
    '#type' => 'textfield',
    '#title' => t('Re-send interval for untested files'),
    '#description' => t('Number of hours to wait before re-sending an untested file to a test server (ie, the test server never sent back the results). Default is 2 hours.'),
    '#required' => TRUE,
    '#default_value' => variable_get('pift_resend_time', 2),
    '#size' => 4,
    '#maxlength' => 4,
    '#validate' => array('pift_server_is_numeric_validate' => array()),
  );

  $form['advanced']['pift_retest_time'] = array(
    '#type' => 'textfield',
    '#title' => t('Re-test interval for previously passed files'),
    '#description' => t('Number of hours to wait before re-testing a previously passed file. Set to -1 to prevent re-testing. Default is 24 hours.'),
    '#required' => TRUE,
    '#default_value' => variable_get('pift_retest_time', 24),
    '#size' => 4,
    '#maxlength' => 4,
    '#validate' => array('pift_server_is_numeric_validate' => array()),
  );

  $form['advanced']['pift_projects'] = array(
    '#type' => 'textarea',
    '#title' => t('Projects to test'),
    '#description' => t("A comma separated list of project ID's (nids) that will be examined for new files. Leave empty for all projects."),
    '#default_value' => variable_get('pift_projects', ''),
    '#validate' => array('pift_server_comma_separated_numeric_validate' => array()),
  );

  $form['advanced']['pift_test_status'] = array(
    '#type' => 'textfield',
    '#title' => t('List of issue statuses to test'),
    '#description' => t("Test files attached to issues that have the following issue statuses (should be a comma separated list of issue sids). Leave empty to test every status."),
    '#default_value' => variable_get('pift_test_status', '8, 14'),
    '#validate' => array('pift_server_comma_separated_numeric_validate' => array()),
  );

  if (module_exists('project_release')) {
    $form['advanced']['pift_server_release_tag_regex'] = array(
      '#type' => 'textfield',
      '#title' => t('Release tag REGEXP'),
      '#description' => t("Enter a MySQL-compatible REGEXP to restrict file testing by the tag column in {project_release_nodes}, for example, <em>^HEAD$</em> -- leave blank for no release tag filtering. "),
      '#default_value' => variable_get('pift_server_release_tag_regex', ''),
    );
  }

  $criteria = array(
    t("The file has failed testing."),
    t("The issue the file is attached to is still passing the file testing filters for project, issue status, and release tag."),
    t("The file is the last testable file posted to the issue."),
  );
  $form['advanced']['pift_server_auto_followup_sid'] = array(
    '#type' => 'textfield',
    '#size' => 4,
    '#maxlength' => 4,
    '#title' => t('Auto followup issue status ID'),
    '#description' => t("Set this to the numeric issue status ID you wish to use for auto followups, or set to 0 to disable auto followups. Auto followups are posted upon return of a file's test results, and may also be triggered if the issue metadata for project, issue status, or release tag is changed.  The auto followup will set the issue's status to the issue status ID listed here, and leave a comment linking to the file result table for the tested file, if the following criteria are met:") . theme('item_list', $criteria),
    '#default_value' => variable_get('pift_server_auto_followup_sid', 0),
    '#validate' => array('pift_server_is_numeric_validate' => array()),
  );

  // Custom submit handler
  $form['#submit']['pift_server_settings_form_extra_submit'] = array();
  // system_settings_form() doesn't add the default if #submit already exists.
  $form['#submit']['system_settings_form_submit'] = array();
  return system_settings_form($form);
}

/**
 * Validation for numeric textfields.
 */
function pift_server_is_numeric_validate($form) {
  if (!is_numeric($form['#value'])) {
    form_set_error($form['#name'], t('%title must be a number.', array('%title' => $form['#title'])));
  }
}

/**
 * Validation for comma separated numeric textfields.
 */
function pift_server_comma_separated_numeric_validate($form) {
  if ($values = $form['#value']) {
    $values = explode(',', $values);
    $values = array_map('trim', $values);
    foreach ($values as $value) {
      if (!is_numeric($value)) {
        form_set_error($form['#name'], t("%title must be a comma separated list of numeric ID's.", array('%title' => $form['#title'])));
        return;
      }
    }
  }
}

/**
 * Handles extra submission tasks on the admin settings page.
 */
function pift_server_settings_form_extra_submit($form_id, $values) {
  global $form_values;

  // Reset the queue.
  if ($values['pift_server_reset_send_queue']) {
    pift_server_reset_send_queue();
    drupal_set_message(t('Send queue reset.'));
  }
  // Remove the setting so it's not saved to {variable}.
  unset($form_values['pift_server_reset_send_queue']);
}

/**
 * Implementation of hook_menu().
 */
function pift_server_menu($may_cache) {
  $items = array();

  if ($may_cache) {
    $access_admin = user_access('administer projects');
    // Admin settings page.
    $items[] = array(
      'path' => 'admin/project/project-issue-file-test-server',
      'title' => t('Project issue file test server settings'),
      'description' => t('Configure sending file tests to test servers.'),
      'callback' => 'drupal_get_form',
      'callback arguments' => array('pift_server_settings_form'),
      'access' => $access_admin,
      'type' => MENU_NORMAL_ITEM,
    );
    // Debug testing links.
    $items[] = array(
      'path' => 'pift-server-file-testing-link',
      'title' => t('Debug links for file test results'),
      'callback' => 'pift_server_debug_file_testing_link',
      'access' => TRUE,
      'type' => MENU_CALLBACK,
    );
    // Manual request for re-test.
    $items[] = array(
      'path' => 'pift-server-request-retest',
      'title' => t('Request to re-test a file'),
      'callback' => 'drupal_get_form',
      'callback arguments' => array('pift_server_request_retest_confirm_form'),
      'access' => user_access('re-test files'),
      'type' => MENU_CALLBACK,
    );
  }
  else {
    // Include the CSS file.
    drupal_add_css(drupal_get_path('module', 'pift_server') .'/pift_server.css');
  }

  return $items;
}

/**
 * Sets the last processed issue/followup to the most
 * recently posted issue/followup, sets the last sent
 * time to the current time, and empties the send queue.
 */
function pift_server_reset_send_queue() {
  variable_set('pift_server_last_sent', time());
  // Remove all untested files.
  // TODO: Do we really want to do this??
  db_query("DELETE FROM {pift_data} WHERE status = %d", PIFT_UNTESTED);
}

/**
 * Adds issue attachments matching PIFT_FILE_REGEX to the send queue.
 *
 * @param $files
 *   An array of file objects.
 */
function pift_server_add_issue_files($files) {
  global $user;
  if (is_array($files)) {
    foreach ($files as $file) {
      // Put the file data into the send queue.
      if (preg_match(PIFT_FILE_REGEX, $file->filename) && file_exists($file->filepath)) {
        $ftid = db_next_id('{pift_data}_ftid');
        db_query("INSERT INTO {pift_data} (ftid, fid, nid, cid, uid, display_data, status, timestamp) VALUES (%d, %d, %d, %d, %d, '%s', %d, %d)", $ftid, $file->fid, $file->nid, 0, $user->uid, '', PIFT_UNTESTED, 0);
      }
    }
  }
}

/**
 * Add followup attachments matching PIFT_FILE_REGEX to the send queue.
 *
 * @param $files
 *   An array of file objects.
 */
function pift_server_add_followup_files($files) {
  global $user;
  if (is_array($files)) {
    foreach ($files as $file) {
      // Put the file data into the send queue.
      if (preg_match(PIFT_FILE_REGEX, $file->filename) && file_exists($file->filepath)) {
        $ftid = db_next_id('{pift_data}_ftid');
        db_query("INSERT INTO {pift_data} (ftid, fid, nid, cid, uid, display_data, status, timestamp) VALUES (%d, %d, %d, %d, %d, '%s', %d, %d)", $ftid, $file->fid, $file->nid, $file->cid, $user->uid, '', PIFT_UNTESTED, 0);
      }
    }
  }
}

/**
 * Adds debug file testing links upon submission of testable patches.
 *
 * @param $file
 *   A testable file object, with PIFT's ftid included.
 */
function pift_server_build_file_testing_links($file) {
  $pass = PIFT_PASSED;
  $fail = PIFT_FAILED;
  $query = "destination=node/$file->nid";
  if (isset($file->cid)) {
    $query .= "#comment-$file->cid";
  }

  $for_file = t(' for file %file', array('%file' => $file->filename));

  $links = '';
  $links .= '<div>';
  $links .= l(t("Manually pass testing"), "pift-server-file-testing-link/$file->ftid/$pass", array(), $query) . $for_file;
  $links .= '</div><div>';
  $links .= l(t("Manually fail testing"), "pift-server-file-testing-link/$file->ftid/$fail", array(), $query) . $for_file;
  $links .= '</div>';

  return $links;
}

/**
 * Callback for manually submitting patch test results.
 *
 * Useful for debugging.
 *
 * @param $ftid
 *   PIFT's file testing ID
 * @param $nid
 *   The issue node ID.
 * @param $cid
 *   Followup comment ID, or zero for an initial issue post.
 * @param $status
 *   Status to set the test result to.  Should be one of
 *   PIFT_PASSED, PIFT_FAILED
 */
function pift_server_debug_file_testing_link($ftid, $status) {
  if (variable_get('pift_server_debug_file_testing_link', '')) {
    // Make sure we have all numeric args.
    $args = func_get_args();
    foreach ($args as $arg) {
      if (!is_numeric($arg)) {
        drupal_set_message(t('non-numeric argument passed'), 'error');
        drupal_goto();
      }
    }
    switch ((int) $status) {
      case PIFT_PASSED:
        $display_data = t('file passed testing');
        break;
      case PIFT_FAILED:
        $display_data = t('file failed testing');
        break;
      default:
        $display_data = '';
        break;
    }
    $file = array(
      'ftid' => $ftid,
      'status' => $status,
      'display_data' => $display_data,
    );
    pift_server_process_files(array($file));
    drupal_goto();
  }
  else {
    drupal_access_denied();
  }

}

/**
 * Builds form for confirming patch retesting.
 *
 * @param $nid
 *   The node ID of the issue the patch is attached to.
 * @param $cid
 *   The comment ID of the followup the patch is attached
 *   to, if any.
 * @param $ftid
 *   The file testing ID of the file to be sent for retesting.
 * @return
 *   A form array.
 *
 */
function pift_server_request_retest_confirm_form($nid, $cid, $ftid) {

  // Make sure we have all numeric args.
  $args = func_get_args();
  foreach ($args as $arg) {
    if (!is_numeric($arg)) {
      drupal_set_message(t('non-numeric argument passed'), 'error');
      drupal_goto("node/$nid");
    }
  }

  if ($cid) {
    $file_info = db_fetch_object(db_query("SELECT pd.ftid, pd.nid, cu.filename FROM {pift_data} pd INNER JOIN {comment_upload_files} cu ON pd.fid = cu.fid WHERE pd.ftid = %d", $ftid));
  }
  else {
    $file_info = db_fetch_object(db_query("SELECT pd.ftid, pd.nid, f.filename FROM {pift_data} pd INNER JOIN {files} f ON pd.fid = f.fid WHERE pd.ftid = %d", $ftid));
  }

  if ($file_info) {
    $form = array();
    $form['file_info'] = array(
      '#type' => 'value',
      '#value' => $file_info,
    );

    return confirm_form(
      $form,
      t('Are you sure you want to submit %file for re-testing?', array('%file' => $file_info->filename)),
      'node/'. $file_info->nid,
      t("The file will only be sent for testing if the current issue's Project, Status, and Release tag settings match the current issue filter settings."),
      t('Retest file'),
      t('Cancel'));
  }
  else {
    drupal_set_message(t('Invalid file submitted.'), 'error');
    drupal_goto("node/$nid");
  }
}

/**
 * Manually requests patch re-testing.
 */
function pift_server_request_retest_confirm_form_submit($form_id, $form_values) {
  $file_info = $form_values['file_info'];
  // Check issue filters here to provide an intelligent user
  // message to the user if the filters don't pass.
  if (pift_server_check_issue_filters($file_info->nid)) {
    db_query("UPDATE {pift_data} SET display_data = '%s', status = %d WHERE ftid = %d", 'manual re-test', PIFT_RETEST, $file_info->ftid);
    // In case the file was removed from the testable files list
    // from the time it was submitted.
    if (db_affected_rows()) {
      drupal_set_message(t('%file has been submitted for re-testing -- results will be posted when testing completes.', array('%file' => $file_info->filename)));
    }
    else {
      drupal_set_message(t('Invalid file submitted.'), 'error');
    }
  }
  else {
    drupal_set_message(t('%file is not currently eligible for re-testing, and was not submitted.', array('%file' => $file_info->filename)), 'error');
  }

  drupal_goto("node/$file_info->nid");
}

/**
 * Marks previously passed files for re-testing, if:
 *   1. The file's last test is older than the retest interval.
 *   2. The file is part of a project that's being tested.
 *   3. The file is attached to an issue that has one of the
 *      issue states marked for testing.
 *
 */
function pift_server_retest_check() {

  // Never re-test files.
  if (PIFT_RETEST_TIME == '-1') {
    return;
  }

  // Set up the retest time limit.
  $retest_time = time() - (PIFT_RETEST_TIME * 60 * 60);

  $where = '';
  $where_parts = array();
  $args = array(PIFT_RETEST, PIFT_PASSED, $retest_time);

  // Restrict to listed projects, if set.
  if ($projects = pift_server_project_list()) {
    $where_parts[] = ' p.nid IN ('. implode(',', array_fill(0, count($projects), '%d')) .')';
    $args = array_merge($args, $projects);
  }

  // Restrict to the status list, if set.
  if ($status_list = pift_server_status_list()) {
    $where_parts[] = 'pi.sid IN ('. implode(',', array_fill(0, count($status_list), '%d')) .')';
    $args = array_merge($args, $status_list);
  }

  // Add in release info if it exists.
  if (module_exists('project_release')) {
    // Restrict to release tag, if set.
    if ($release_tag_regex = variable_get('pift_server_release_tag_regex', '')) {
      $join = ' INNER JOIN {project_release_nodes} prn ON pi.rid = prn.nid';
      $where_parts[] = "prn.tag REGEXP '%s'";
      $args[] = $release_tag_regex;
    }
    else {
      $join = '';
    }
  }

  if (!empty($where_parts)) {
    $where .= " AND nid IN (SELECT pi.nid FROM {project_issues} pi INNER JOIN {node} p ON p.nid = pi.pid$join WHERE ". implode(' AND ', $where_parts) .")";
  }

  db_query("UPDATE {pift_data} SET status = %d WHERE status = %d AND timestamp < %d$where", $args);
}

/**
 * Sends file data to test servers, in a round robin approach.
 *
 * The files will be sent via XML-RPC to any servers listed on the settings page,
 * which also have a valid Project issue file review module installed and configured
 * with the server key of the PIFT server (available on the PIFT server settings page).
 *
 * The files will be sent in an array, each element of which is an associative array
 * with the following key/value pairs:
 *
 *     'ftid'          => The file test ID that was originally passed from
 *                       the test server for the file in question.
 *
 *     'cid'           => The comment ID of the comment the patch is
 *                        attached to.
 *
 *     'pid'           => The project ID.
 *
 *     'rid'           => The release ID.
 *
 *     'uid'           => The uid of the user who submitted the file.
 *
 *     'issue_id'      => nid of the issue.
 *
 *     'issue_title'   => Title of the issue.
 *
 *     'project'       => Project the patch is for.
 *
 *     'version'       => Project version string.
 *
 *     'tag'           => Release tag as found in {project_release_nodes}.
 *
 *     'submitter'     => Drupal user submitting the patch.
 *
 *     'patch_url'     => The absolute URL for the file.
 */
function pift_server_send_file_data() {
  global $base_url;

  // Get servers if any exist.
  if ($all_server_data = variable_get('pift_server_sites', '')) {
    $all_server_data = explode("\n", $all_server_data);
    $servers = array();
    $i = 0;

    // Set up the test servers.
    foreach ($all_server_data as $server_data) {
      if ($server_data) {
        // Set up the login data for the server. The test server needs
        // it's server key for authentication.
        $server_data = explode('@', $server_data);
        $server['server_key'] = $server_data[0];
        $server['xmlrpc_url'] = $server_data[1];
        // Basic testing to make sure the XML-RPC URL isn't totally bogus.
        if (preg_match('/^(http|https):\/\/.+\/xmlrpc.php/', $server['xmlrpc_url'])) {
          $i++;
          $servers[$i] = $server;
        }
        // Bad server URL.
        else {
          watchdog('project_remote', t('%server is an invalid URL.', array('%server' => $server_xmlrpc_url)), WATCHDOG_ERROR);
        }
      }
    }
    if (empty($servers)) {
      return;
    }
  }
  else {
    return;
  }

  // Set up the resend time limit.
  $resend_time = time() - (PIFT_RESEND_TIME * 60 * 60);

  $where = '';
  $where_args = array();
  $sub_query_args = array(PIFT_UNTESTED, $resend_time, PIFT_RETEST, 0);

  // Restrict to listed projects, if set.
  if ($projects = pift_server_project_list()) {
    $where .= ' AND p.nid IN ('. implode(',', array_fill(0, count($projects), '%d')) .')';
    $where_args = array_merge($where_args, $projects);
  }

  // Restrict to the status list, if set.
  if ($status_list = pift_server_status_list()) {
    $where .= ' AND pi.sid IN ('. implode(',', array_fill(0, count($status_list), '%d')) .')';
    $where_args = array_merge($where_args, $status_list);
  }

  // Add in release info if it exists.
  if (module_exists('project_release')) {
    $select = ', prn.version, prn.tag';
    $join = ' LEFT JOIN {project_release_nodes} prn ON pi.rid = prn.nid';
    // Restrict to release tag, if set.
    if ($release_tag_regex = variable_get('pift_server_release_tag_regex', '')) {
      $where .= " AND prn.tag REGEXP '%s'";
      $where_args[] = $release_tag_regex;
    }
  }
  else {
    $select = '';
    $join = '';
  }

  // Assemble final args.
  $args = array_merge($sub_query_args, $where_args, $sub_query_args, $where_args);

  // Pull issue files that need to be sent for testing.  These include:
  // 1. All files marked as untested that have exceeded the resend period.
  //    since their last send (includes newly added files).
  // 2. All files that have been marked for re-testing.
  // This is one god awful query...  :(
  $files = db_query_range("(SELECT pd.ftid, pd.cid, n.nid AS issue_id, n.title AS issue_title, n.uid, pi.pid, pi.rid, f.filepath AS patch_url, p.title AS project, u.name AS submitter$select FROM {pift_data} pd INNER JOIN {project_issues} pi ON pd.nid = pi.nid INNER JOIN {files} f ON pd.fid = f.fid INNER JOIN {node} n ON n.nid = pi.nid INNER JOIN {node} p ON p.nid = pi.pid INNER JOIN {users} u ON u.uid = pd.uid$join WHERE ((pd.status = %d AND pd.timestamp < %d) OR pd.status = %d) AND pd.cid = %d$where) UNION (SELECT pd.ftid, pd.cid, n.nid AS issue_id, n.title AS issue_title, n.uid, pi.pid, pi.rid, cu.filepath AS patch_url, p.title AS project, u.name AS submitter$select FROM {pift_data} pd INNER JOIN {project_issues} pi ON pd.nid = pi.nid INNER JOIN {comment_upload_files} cu ON pd.fid = cu.fid INNER JOIN {node} n ON n.nid = pi.nid INNER JOIN {node} p ON p.nid = pi.pid INNER JOIN {users} u ON u.uid = pd.uid$join WHERE ((pd.status = %d AND pd.timestamp < %d) OR pd.status = %d) AND pd.cid <> %d$where) ORDER BY ftid", $args, 0, PIFT_SEND_LIMIT);

  // Nothing to do.
  if (!db_num_rows($files)) {
    return;
  }

  // Set up the batching variables.
  $bid = 0;
  $batches = array();
  $batch_total = 0;
  $sent_files = array();

  // Send new data if there is any.
  while ($file = db_fetch_array($files)) {
    if (is_readable($file['patch_url'])) {
      // Start the next batch if the current one is full.
      if ($batch_total >= PIFT_BATCH_SIZE) {
        $bid++;
        $batch_total = 0;
      }
      // Convert filepath to absolute URL.
      $file['patch_url'] = url($file['patch_url'], NULL, NULL, TRUE);
      // Add the file to the current batch.
      $batches[$bid][] = $file;
      // Add to the list of files that will be sent with this batch.
      $sent_files[$bid][] = $file['ftid'];
      // Increment both the current batch size, and the total size.
      $batch_total++;
    }
    // File is not readable, mark as such.
    else {
      db_query("UPDATE {pift_data} SET status = %d WHERE ftid = %d", PIFT_NOT_READABLE, $file['ftid']);
    }
  }

  $sent = array();

  // Get the next server in the round robin cycle.
  $s = variable_get('pift_next_test_server', 1);

  $server_key = pift_server_server_key();

  // Send batches, round robin.
  foreach ($batches as $bid => $batch) {
    // We're at the end of the server line, start over.
    if ($s > $i) {
      $s = 1;
    }
    // Send batch.
    $result = xmlrpc($servers[$s]['xmlrpc_url'], 'pifr.batch.queue', $server_key, $batch);

    // Failed XML-RPC call.
    if ($result === FALSE) {
      pift_server_xmlrpc_error_handler($servers[$s]);
    }
    // Failed test server validation.
    elseif (isset($result['error'])) {
      pift_server_xmlrpc_error_handler($servers[$s], $result['error']);
    }
    // List of successful sends.
    else {
      // Update the last sent timestamp for this batch of files.
      db_query("UPDATE {pift_data} SET timestamp = %d WHERE ftid IN (". implode(', ', $sent_files[$bid]) .")", time());
      $sent[] = check_plain($servers[$s]['xmlrpc_url']) .' -- '. format_plural(count($sent_files[$bid]), '1 file sent', '@count files sent');
    }
    // Next server in line.
    $s++;
    variable_set('pift_next_test_server', $s);
  }

  // Record successful sends.
  if (!empty($sent)) {
    watchdog('project_remote', t('Project issue data sent successfully to the following servers:!servers', array('!servers' => theme('item_list', $sent))));
  }
}

/**
 * Implementation of hook_xmlrpc()
 */
function pift_server_xmlrpc() {
  return array(
    array(
      'pift.test.results',
      'pift_server_process_test_results',
      array('struct', 'struct', 'struct'),
      t('receive file test results from a test server')
    ),
  );
}

/**
 * Validates incoming test results and passes them along for processing.
 *
 * @param $server
 *   An associative array of login parameters, as follows:
 *     'url'        => The Full XML-RPC URL of the server sending the
 *                      data, ex. http://example.com/xmlrpc.php
 *     'server_key' => The server key for the server sending the data.
 *
 * @param $files
 *   An array of files to process. Each element an associative array
 *   of information for one file, as follows:
 *     'ftid'         => The file test ID that was originally passed to
 *                       the test server for the file in question.
 *
 *     'status'       => The file's test status (passed, failed, etc.).
 *
 *     'display_data' => Optional. A string of additional data to display
 *                       when rendering the file test results.
 *
 * @return
 *   An empty array if the test data was properly validated,
 *   otherwise an associative array with these key/value pairs:
 *     'error' => PIFT_XMLRPC_INVALID_SERVER | PIFT_XMLRPC_INVALID_SERVER_KEY
 */
function pift_server_process_test_results($server, $files) {
  // Build an array of valid test servers for this install.
  $test_servers = explode("\n", variable_get('pift_server_sites', ''));
  $valid_servers = array();
  foreach ($test_servers as $test_server) {
    if ($test_server) {
      $parts = explode('@', $test_server);
      $valid_servers[$parts[1]] = $parts[0];
    }
  }
  // Validate the test server URL against the list of valid test servers.
  if (isset($valid_servers[$server['url']])) {
    // Validate the server key for the test server.
    if ($valid_servers[$server['url']] == $server['server_key']) {
      pift_server_process_files($files);
      return array();
    }
    // Bad login.
    else {
      watchdog('project_remote', t('%server attempted to send file test data, and has an invalid server key.', array('%server' => $server['url'])), WATCHDOG_WARNING);
      return array('error' => 'PIFT_XMLRPC_INVALID_SERVER_KEY');
    }
  }
  // Bad test server.
  else {
    watchdog('project_remote', t('%server attempted to send file test data, and is not on the valid server list.', array('%server' => $server['url'])), WATCHDOG_WARNING);
    return array('error' => 'PIFT_XMLRPC_INVALID_SERVER');
  }
}

/**
 * Processing incoming file tests, and stores the results.
 *
 * @param $files
 *   An array of files to process. Each element an associative array
 *   of information for one file, as follows:
 *     'ftid'         => The file test ID that was originally passed to
 *                       the test server for the file in question.
 *
 *     'status'       => The file's test status (passed, failed, etc.).
 *
 *     'display_data' => Optional. A string of addition data to display
 *                       when rendering the file test results.
 */
function pift_server_process_files($files) {
  $ftids = array();
  $time = time();
  foreach ($files as $file) {
    // Discard the result data if the file isn't a testable file anymore.
    if ($nid = db_result(db_query("SELECT nid FROM {pift_data} WHERE ftid = %d", $file['ftid']))) {
      if (pift_server_check_issue_filters($nid)) {
        // Update the entry that was originally entered for this file,
        // and set the last tested timestamp to the current time.
        db_query("UPDATE {pift_data} SET display_data = '%s', status = %d, timestamp = %d WHERE ftid = %d", $file['display_data'], $file['status'], $time, $file['ftid']);
        $ftids[] = $file['ftid'];
        $file['issue_id'] = $nid;
        pift_server_check_auto_followup($file);
      }
      else {
        // File test result didn't pass filters, but still update the testing timestamp.
        db_query("UPDATE {pift_data} SET timestamp = %d WHERE ftid = %d", $time, $file['ftid']);
      }
    }
  }
  pift_server_mail_failed_tests($ftids);
}

/**
 * E-mails subscribed users when their file fails regression testing.
 *
 * @param $ftids
 *   An array of file test ID's to check for failure.
 */
function pift_server_mail_failed_tests($ftids) {
  // E-mail functionality is disabled.
  if (!($mail_text = variable_get('pift_failed_test_mail_text', ''))) {
    return;
  }

  // Filter out bad/risky data.
  $ftids = array_filter($ftids, 'is_numeric');
  if (!empty($ftids)) {
    $site_name = variable_get('site_name', 'Drupal');

    // Pull only the file data for files that have failed, and that
    // relate to a use that's subscribe to receive test failure emails.
    $issue_emails = db_query("SELECT u.name, u.mail, n.title, pd.fid, pd.nid, pd.cid, pd.display_data FROM {pift_data} pd INNER JOIN {node} n ON n.nid = pd.nid INNER JOIN {pift_subscriptions} ps ON pd.uid = ps.uid INNER JOIN {users} u ON u.uid = pd.uid WHERE n.status = 1 AND u.status = 1 AND pd.ftid IN (". implode(', ', $ftids) .") AND pd.status = %d", PIFT_FAILED);

    while ($mail = db_fetch_object($issue_emails)) {

      // Pull the filepath here, since we can't get it from the query above --
      // it could be coming from two different places. Send user directly to
      // the comment if the file was attached to a comment.
      if ($mail->cid) {
        $table = '{comment_upload_files}';
        $fragment = "comment-$mail->cid";
      }
      else {
        $table = '{files}';
        $fragment = NULL;
      }
      $filepath = db_result(db_query("SELECT filepath FROM $table WHERE fid = %d", $mail->fid));

      if (is_readable($filepath)) {
        $variables = array(
          '!username' => $mail->name,
          '!site' => $site_name,
          '!issue_title' => $mail->title,
          '!issue_url' => url('node/'. $mail->nid, NULL, $fragment, TRUE),
          '!date' => format_date(time()),
          '!reason' => $mail->display_data,
          '!filepath' => url($filepath, NULL, NULL, TRUE),
        );

        $body = strtr($mail_text, $variables);
        $subject = t('!site Testbed server', array('!site' => $site_name));
        drupal_mail('pift_failed_test', $mail->mail, $subject, $body);
      }
    }
  }
}

/**
 * Checks an issue to see if it still passes testable file filters.
 *
 * @param $nid
 *   The issue node the file is attached to.
 */
function pift_server_check_issue_filters($nid) {

  $join = '';
  $where = '';
  $args = array($nid);

  // Restrict to listed projects, if set.
  if ($projects = pift_server_project_list()) {
    $where .= ' AND pi.pid IN ('. implode(',', array_fill(0, count($projects), '%d')) .')';
    $args = array_merge($args, $projects);
  }

  // Restrict to the status list, if set.
  if ($status_list = pift_server_status_list()) {
    $where .= ' AND pi.sid IN ('. implode(',', array_fill(0, count($status_list), '%d')) .')';
    $args = array_merge($args, $status_list);
  }

  // Restrict to release tag, if set.
  if (module_exists('project_release')) {
    if ($release_tag_regex = variable_get('pift_server_release_tag_regex', '')) {
      $join = ' LEFT JOIN {project_release_nodes} prn ON pi.rid = prn.nid';
      $where .= " AND prn.tag REGEXP '%s'";
      $args[] = $release_tag_regex;
    }
  }

  // Pull last testable file for the issue.
  $passed_filters = db_result(db_query("SELECT pi.nid FROM {project_issues} pi$join WHERE pi.nid = %d$where", $args));

  return $passed_filters;
}

/**
 * Checks a file to see if an auto status change is needed.
 *
 * Only files that have failed testing are eligible.  If the
 * auto followup sid is set, and the file failed testing, and the
 * file is the last testable file posted to the issue, then it
 * leaves a followup setting the issue sid to the auto followup
 * sid.
 *
 * @param $file
 *   An associative array of file test result information,
 *   with the following key/value pairs:
 *
 *     ftid     => The file test ID passed to the testing server.
 *     issue_id => The issue node the file is attached to.
 *     status   => The test result, should be on of the
 *                 constants PIFT_PASSED, PIFT_FAILED
 */
function pift_server_check_auto_followup($file) {

  // Only if an auto change followup sid is set, and only for failed files.
  if (variable_get('pift_server_auto_followup_sid', 0) && $file['status'] == PIFT_FAILED) {
    $join = '';
    $where = '';
    $args = array($file['issue_id']);

    // Restrict to listed projects, if set.
    if ($projects = pift_server_project_list()) {
      $where .= ' AND pi.pid IN ('. implode(',', array_fill(0, count($projects), '%d')) .')';
      $args = array_merge($args, $projects);
    }

    // Restrict to the status list, if set.
    if ($status_list = pift_server_status_list()) {
      $where .= ' AND pi.sid IN ('. implode(',', array_fill(0, count($status_list), '%d')) .')';
      $args = array_merge($args, $status_list);
    }

    // Restrict to release tag, if set.
    if (module_exists('project_release')) {
      if ($release_tag_regex = variable_get('pift_server_release_tag_regex', '')) {
        $join = ' LEFT JOIN {project_release_nodes} prn ON pi.rid = prn.nid';
        $where .= " AND prn.tag REGEXP '%s'";
        $args[] = $release_tag_regex;
      }
    }

    // Pull last testable file for the issue.
    $last_file = db_fetch_object(db_query_range("SELECT pd.ftid, pd.nid, pd.cid, pd.status FROM {pift_data} pd INNER JOIN {project_issues} pi ON pd.nid = pi.nid$join WHERE pd.nid = %d$where ORDER BY ftid DESC", $args, 0, 1));

    // There's an attached testable file on the issue, and
    // the file in question is the last file attached to the
    // issue.
    if ($last_file && $file['ftid'] == $last_file->ftid) {
      pift_server_auto_followup($last_file);
    }
  }
}

/**
 * Posts a followup to an issue.
 *
 * Sets the issue sid to the auto followup sid.
 *
 * @param $last_file
 *   A testable file object.
 */
function pift_server_auto_followup($last_file) {

  project_issue_add_followup(array(
    'nid' => $last_file->nid,
    'sid' => variable_get('pift_server_auto_followup_sid', 0),
    'comment' => theme('pift_server_auto_close_message', $last_file),
  ));
}

/**
 * Implementation of hook_nodeapi().
 */
function pift_server_nodeapi(&$node, $op, $arg) {
  if ($node->type == 'project_issue') {
    // Add attachments for this node to the send queue.
    if ($op == 'insert') {
      $files = upload_load($node);
      pift_server_add_issue_files($files);
    }
    // Only display test results for issue nodes when it's a full view.
    elseif (arg(0) == 'node' && is_numeric(arg(1))) {
      switch ($op) {
        case 'view':
          // Pull file attachments for this issue node.
          $result = db_query("SELECT f.filename, pd.ftid, pd.nid, pd.display_data, pd.status FROM {pift_data} pd INNER JOIN {files} f ON pd.fid = f.fid WHERE pd.nid = %d AND pd.cid = %d AND f.filepath <> '' AND pd.status <> %d ORDER BY ftid", $node->nid, 0, PIFT_UNTESTED);
          $display = array();

          // Load the files into an array to pass to the theming function.
          $retest = user_access('re-test files');
          while ($file = db_fetch_array($result)) {
            $display[$file['ftid']] = array(
              'filename' => check_plain($file['filename']),
              'status' => $file['status'],
              'display_data' => filter_xss_admin($file['display_data']),  // Coming from a trusted server, relaxed filtering.
            );
          }
          // Display table just below file attachment.
          $node->content['file_test_data'] = array(
            '#value' => theme('pift_server_results', $display, $node->nid, 0, $retest),
            '#weight' => 51,  // Just below the upload attachments.
          );
          // Debug display.
          $debug_links = variable_get('pift_server_debug_file_testing_link', '');
          if ($debug_links) {
            $files = upload_load($node);
            $debug_test_links = array();
            foreach ($files as $file) {
              if (preg_match(PIFT_FILE_REGEX, $file->filename) && file_exists($file->filepath) && ($ftid = db_result(db_query("SELECT ftid FROM {pift_data} WHERE nid = %d AND cid = 0 AND fid = %d", $file->nid, $file->fid)))) {
                $file->ftid = $ftid;
                $debug_test_links[] = pift_server_build_file_testing_links($file);
              }
            }
          }
          if (!empty($debug_test_links)) {
            $node->content['file_test_debug_links'] = array(
              '#value' => theme('item_list', $debug_test_links),
              '#weight' => 52,  // Just below the upload attachments.
            );
          }
          break;
        case 'delete':
          // Remove related data in the test results table.
          db_query("DELETE FROM {pift_data} WHERE nid = %d", $node->nid);
          break;
        case 'update':
          // If files were deleted, remove related data in the test results table.
          if (is_array($node->files)) {
            foreach ($node->files as $file) {
              // Can be either an array or object as this point.
              $file = (object) $file;
              if ($file->remove) {
                db_query("DELETE FROM {pift_data} WHERE nid = %d AND fid = %d", $node->nid, $file->fid);
              }
            }
          }
          break;
      }
    }
  }
}

/**
 * Implementation of hook_user().
 */
function pift_server_user($type, $edit, &$user, $category = NULL) {
  if ($type == 'delete') {
    db_query("DELETE FROM {pift_subscriptions} WHERE uid = %d", $user->uid);
    db_query("UPDATE {pift_data} SET uid = 0 WHERE uid = %d", $user->uid);
  }
}

/**
 * Implementation of hook_comment().
 */
function pift_server_comment(&$comment, $op) {
  static $cids = NULL;

  // $comment can be a comment object, or a form or form_values.
  if (is_object($comment)) {
    $nid = $comment->nid;
  }
  elseif (is_array($comment)) {
    $nid = is_array($comment['nid']) ? $comment['nid']['#value'] : $comment['nid'];
  }
  $node = node_load($nid);
  if ($node->type != 'project_issue') {
    return;
  }

  switch ($op) {
    case 'view':

      // To boost performance, cache the test results for all issue followups
      // at once, then grab the display data from the cache.
      if (!isset($cids)) {
        $cids = array();
        // Pull file attachments for all followups on the issue.
        $result = db_query("SELECT cu.cid, cu.filename, cu.description, pd.ftid, pd.nid, pd.cid, pd.display_data, pd.status FROM {pift_data} pd INNER JOIN {comment_upload_files} cu ON pd.fid = cu.fid WHERE pd.nid = %d AND pd.cid <> %d AND status <> %d ORDER BY ftid", $node->nid, 0, PIFT_UNTESTED);

        // Load the files into an array to pass to the theming function.
        $retest = user_access('re-test files');
        while ($file = db_fetch_array($result)) {
          $cids[$file['cid']][$file['ftid']] = array(
            'filename' => check_plain($file['filename']),
            'description' => check_plain($file['description']),
            'status' => $file['status'],
            'display_data' => filter_xss_admin($file['display_data']),
          );
        }

        // Convert the results to themed display tables.
        foreach ($cids as $cid => $display) {
          $cids[$cid] = theme('pift_server_results', $display, $nid, $cid, $retest);
        }
      }

      // Add the test result display to the end of the comment.
      // TODO: When comment module's rendering isn't so whack,
      // always put this right after the attachment table.
      if (!empty($cids[$comment->cid])) {
        $comment->comment .= $cids[$comment->cid];
      }
      // Debug display.
      $debug_links = variable_get('pift_server_debug_file_testing_link', '');
      if ($debug_links) {
        $files = _comment_upload_load_files($comment->cid);
        if (is_array($files)) {
          $debug_test_links = array();
          foreach ($files as $file) {
            if (preg_match(PIFT_FILE_REGEX, $file->filename) && file_exists($file->filepath) && ($ftid = db_result(db_query("SELECT ftid FROM {pift_data} WHERE nid = %d AND cid = %d AND fid = %d", $file->nid, $file->cid, $file->fid)))) {
              $file->ftid = $ftid;
              $debug_test_links[] = pift_server_build_file_testing_links($file);
            }
          }
        }
        if (!empty($debug_test_links)) {
          $comment->comment .= theme('item_list', $debug_test_links);
        }
      }
      break;
    case 'insert':
      // Add attachments to this comment to the send queue.
      $files = _comment_upload_load_files($comment['cid']);
      pift_server_add_followup_files($files);
      pift_server_check_followup_metadata($comment);
      break;
    case 'update':
      // If files were deleted, remove related data in the test results table.
      if (is_array($comment['files'])) {
        foreach ($comment['files'] as $file) {
          // Can be either an array or object as this point.
          $file = (object) $file;
          if ($file->remove) {
            db_query("DELETE FROM {pift_data} WHERE cid = %d AND fid = %d", $comment['cid'], $file->fid);
          }
        }
      }
      break;
    case 'delete':
      // Remove related data in the test results table.
      db_query("DELETE FROM {pift_data} WHERE cid = %d", $comment->cid);
      break;
  }
}

function pift_server_check_followup_metadata($comment) {

  $auto_followup_sid = variable_get('pift_server_auto_followup_sid', 0);

  // If no auto followup sid exists, then this check isn't necessary.
  if (!$auto_followup_sid) {
    return;
  }

  $projects = pift_server_project_list();
  $status_list = pift_server_status_list();
  $pid = $comment['project_info']['pid'];
  $sid = $comment['sid'];
  $rid = $comment['project_info']['rid'];
  $nid = $comment['nid'];
  $release_tag_regex = variable_get('pift_server_release_tag_regex', '');

  // Only proceed with checking if the current project and issue
  // status pass the filters. There's no easy way to check the
  // release tag filter here, so we'll check it when we pull the
  // last testable file.
  if ((empty($projects) || in_array($pid, $projects)) && (empty($status_list) || in_array($sid, $status_list))) {
    // We have to check to see if either pid, sid, or rid
    // has actually changed. There's no reliable way to do this
    // without querying {project_issue_comments} for it.
    $last_post = db_fetch_object(db_query_range("SELECT pid, sid, rid FROM {project_issue_comments} WHERE nid = %d AND cid <> %d ORDER BY cid DESC", $nid, $comment['cid'], 0, 1));
    // This comment being inserted is the first followup, so get
    // pid, sid, and rid from the issue itself.
    if (!$last_post) {
      $last_post = db_fetch_object(db_query("SELECT pid, sid, rid FROM {project_issues} WHERE nid = %d", $nid));
    }
    // A metadata change only matters if a filter is set, and
    // we need at least one piece of metadata to have changed.
    $metadata_change = (!empty($projects) && $last_post->pid != $pid) || (!empty($status_list) && $last_post->sid != $sid) || (!empty($release_tag_regex) && $last_post->rid != $rid);
    // Continue if there was a metadata change, except
    // in the special case where a user is trying to manually
    // set the issue state from the auto followup state to a testable
    // state, we want to allow this.
    if ($metadata_change && $last_post->sid != $auto_followup_sid) {
      $join = '';
      $where = '';
      $args = array($nid);
      // Restrict to release tag, if set.
      if (module_exists('project_release') && $release_tag_regex) {
        $join = ' INNER JOIN {project_issues} pi ON pd.nid = pi.nid LEFT JOIN {project_release_nodes} prn ON pi.rid = prn.nid';
        $where .= " AND prn.tag REGEXP '%s'";
        $args[] = $release_tag_regex;
      }

      // Pull last testable file for the issue.
      $last_file = db_fetch_object(db_query_range("SELECT pd.nid, pd.cid, pd.status FROM {pift_data} pd$join WHERE pd.nid = %d$where ORDER BY ftid DESC", $args, 0, 1));

      // There's an attached testable file on the issue, and
      // the last testable file has failed testing.
      if ($last_file && $last_file->status == PIFT_FAILED) {
        pift_server_auto_followup($last_file);
      }
    }
  }
}

/**
 * Theme test result data into a table.
 *
 * @param $results
 *   An array of test result data.
 * @param $nid
 *   The issue node ID.
 * @param $cid
 *   The comment ID (optional).
 * @param $retest
 *   Boolean indicating if a re-test link should be provided.
 * @return
 *   An HTML string of the rendered table.
 */
function theme_pift_server_results($results, $nid, $cid, $retest) {
  $rows = array();
  $output = '';

  // One row for each file test result.
  foreach ($results as $ftid => $result) {
    $description = $result['description'] ? $result['description'] : $result['filename'];
    $retest_link = $retest ? ' - '. l(t('Request re-test'), "pift-server-request-retest/$nid/$cid/$ftid") : '';
    switch ($result['status']) {
      // File passed testing.
      case PIFT_PASSED:
        $rows[] = array(
          'data' => array(
            $description,
            t('passed') . $retest_link,
            $result['display_data'],  // Already filtered.
          ),
          'class' => 'pift-passed',
        );
        break;
      // File failed testing.
      case PIFT_FAILED:
        $rows[] = array(
          'data' => array(
            $description,
            t('failed') . $retest_link,
            $result['display_data'],  // Already filtered.
          ),
          'class' => 'pift-failed',
        );
        break;
    }
  }

  // Only build the table if there are results to display.
  if (!empty($rows)) {
    $header = array(
      array(
        'data' => t('Testbed results'),
        'colspan' => '3',
      )
    );

    $id = "file-test-results-$nid";
    if (isset($cid)) {
      $id .= "-$cid";
    }

    $output = '<div id="'. $id .'" class="file-test-results">'. theme('table', $header, $rows) .'</div>';
  }

  return $output;
}

/**
 * Themes the comment posted on auto followups.
 *
 * @param $last_file
 *   A testable file object.
 */
function theme_pift_server_auto_close_message($last_file) {

  $output = '';
  $id = "#file-test-results-$last_file->nid";
  if ($last_file->cid) {
    $id .= "-$last_file->cid";
  }
  $output .= t('The last submitted patch <a href="@link">failed testing</a>.', array('@link' => $id));

  return $output;
}

/**
 * Records XML-RPC errors communicating to test servers.
 *
 * @param $server
 *   An associative array of server information, as follows:
 *     'user' => The user logging in.
 *     'xmlrpc_url' => The XML-RPC URL of the test server.
 *     'url'  => The Drupal base URL of the server sending the data.
 *
 * @param $error_code
 *   Optional. A string representing a validation error type.
 */
function pift_server_xmlrpc_error_handler($server, $error_code = NULL) {
  global $base_url;

  $t_args = array('%url' => $base_url, '%xmlrpc_url' => $server['xmlrpc_url']);

  switch ($error_code) {
    case 'PIFT_XMLRPC_INVALID_SERVER':
      watchdog('project_remote', t('%url is not listed as a valid project server at test server %xmlrpc_url', $t_args), WATCHDOG_ERROR);
      break;
    case 'PIFT_XMLRPC_INVALID_SERVER_KEY':
      watchdog('project_remote', t('Unable to log in %url to %xmlrpc_url -- invalid server key.', $t_args), WATCHDOG_ERROR);
      break;
    default:
      watchdog('project_remote', t('XML-RPC error communicating with %xmlrpc_url', $t_args), WATCHDOG_ERROR);
      break;
  }
}

/**
 * Checks to see if the project is currently being monitored by
 * pift_s for file testing.
 *
 * @param $pid
 *   The project nid.
 * @return
 *   TRUE if the project is in the active project list, or if the list
 *   is empty.  FALSE otherwise.
 */
function pift_server_active_project($pid) {
  if ($projects = pift_server_project_list()) {
    return in_array($pid, $projects);
  }
  else {
    return TRUE;
  }
}

/**
 * Formats the active project list into an array.
 *
 * @return
 *   An array of the active projects that will be examined for testing.
 */
function pift_server_project_list() {
  if ($projects = variable_get('pift_projects', '')) {
    $projects = explode(',', $projects);
    $projects = array_map('trim', $projects);
    return $projects;
  }
  else {
    return array();
  }
}

/**
 * Formats the active status list into an array.
 *
 * @return
 *   An array of the statuses that will be examined for re-testing.
 */
function pift_server_status_list() {
  if ($status_list = variable_get('pift_test_status', '8, 14')) {
    $status_list = explode(',', $status_list);
    $status_list = array_map('trim', $status_list);
    return $status_list;
  }
  else {
    return array();
  }
}

/**
 * Generates the XML-RPC server key.
 *
 * @return
 *   The server key.
 */
function pift_server_server_key() {
  global $base_url;
  return md5(drupal_get_private_key() . $base_url);
}
