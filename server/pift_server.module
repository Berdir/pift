<?php
// $Id$
// $Name$

/**
 * Advanced settings section
 */
// Limit on how many files to send for each cron run.
define('PIFT_SEND_LIMIT', variable_get('pift_send_limit', 100));
// Number of files to send in a single call to a test server.
define('PIFT_BATCH_SIZE', variable_get('pift_batch_size', 20));
// Regex for determining which file types should be sent for testing.
define('PIFT_FILE_REGEX', variable_get('pift_file_regex', '/(\.diff|\.patch)$/'));
// Number of hours to wait before resending an untested file to a test
// server (ie, the test server never sent back the results).
define('PIFT_RESEND_TIME', variable_get('pift_resend_time', 2));
// Number of hours to wait before retesting a previously passes file.
define('PIFT_RETEST_TIME', variable_get('pift_retest_time', 24));

// File testing status definitions.
define('PIFT_UNTESTED', 0);
define('PIFT_PASSED', 1);
define('PIFT_FAILED', 2);
define('PIFT_RETEST', 3);
define('PIFT_NOT_READABLE', 4);

/**
 * Implementation of hook_cron().
 */
function pift_server_cron() {
  $send = variable_get('pift_server_send_frequency', -1);
  // Check if sending is enabled.
  if ($send != -1) {
    $time = time();
    // Get time last sent.
    $last_sent = variable_get('pift_server_last_sent', time());
    $frequency = $send * 60;
    // Time to send again?
    if ($time > ($last_sent + $frequency)) {
      pift_server_add_new_files();
      pift_server_retest_check();
      pift_server_send_file_data();
      // Update last sent time.
      variable_set('pift_server_last_sent', $time);
    }
  }
}

/**
 * Implementation of hook_form_alter.
 */
function pift_server_form_alter($form_id, &$form) {
  global $user;
  switch ($form_id) {
    case 'project_issue_subscribe':
      // TODO: Would be nice to have this at the top of the form,
      // but the theming function for the form always puts it at
      // the bottom...  :(
      $form['pift_server_failed_test_mail_subscribe'] = array(
        '#type' => 'checkbox',
        '#title' => t('Receive notification of failed patch tests.'),
        '#default_value' => db_result(db_query("SELECT uid FROM {pift_subscriptions} WHERE uid = %d", $user->uid)),
        '#description' => t('Check here to receive e-mail notification when one of your posted patches fails regression testing.'),
        '#weight' => -10,
      );
      $form['#submit']['pift_server_failed_test_mail_subscribe_submit'] = array();
      break;
    case 'comment_form':
      $node = node_load($form['nid']['#value']);
      if ($node->type == 'project_issue') {
        // Add in custom description for file testing.
        if (isset($form['attachments']['wrapper']['new']['upload']) && pift_server_active_project($node->pid)) {
          $description = filter_xss_admin(variable_get('pift_server_file_description', ''));
          $form['attachments']['wrapper']['new']['upload']['#description'] .= $description;
        }
      }
      break;
    case 'project_issue_node_form':
      // Add in custom description for file testing, test here for the existence of a project,
      // so the description doesn't get added to page 1 of the new issue form.
      if (isset($form['project_info']['pid']['#default_value']) && isset($form['attachments']['wrapper']['new']['upload']) && pift_server_active_project($form['project_info']['pid']['#default_value'])) {
        $description = filter_xss_admin(variable_get('pift_server_file_description', ''));
        $form['attachments']['wrapper']['new']['upload']['#description'] .= $description;
      }
      break;
  }
}

/**
 * Submits the pift subscription setting for the current user.
 */
function pift_server_failed_test_mail_subscribe_submit($form_id, $form_values) {
  global $user;
  // Only insert a row if the checkbox is newly checked.
  if ($form_values['pift_server_failed_test_mail_subscribe']) {
    if (!db_result(db_query("SELECT uid FROM {pift_subscriptions} WHERE uid = %d", $user->uid))) {
      db_query("INSERT INTO {pift_subscriptions} (uid) VALUES (%d)", $user->uid);
    }
  }
  // Always remove if not checked.
  else {
    db_query("DELETE FROM {pift_subscriptions} WHERE uid = %d", $user->uid);
  }
}

/**
 * Implementation of hook_help().
 */
function pift_server_help($section) {
  switch ($section) {
    // Server settings page.
    case 'admin/project/project-issue-test-file-server':
      return t("
      <p>These settings configure the Project issue file test server module's remote communications to file test servers.</p>
      ");
      break;
  }
}

/**
 * Callback for the main settings page.
 */
function pift_server_settings_form() {

  $options = array(
    -1 => t('Disabled'),
    0 => t('Each cron run'),
    60 => t('Hourly'),
    1440 => t('Daily'),
    10080 => t('Weekly'),
    40320 => t('Monthly'),
  );

  $form['pift_server_send_frequency'] = array(
    '#type' => 'select',
    '#title' => t('Send frequency'),
    '#options' => $options,
    '#default_value' => variable_get('pift_server_send_frequency', -1),
    '#description' => t("How often new files should be sent to test servers."),
  );

  // Warn about node access and login security issues.
  $form['pift_server_access_warning'] = array(
    '#prefix' => '<div class="pift-server-warning">',
    '#suffix' => '</div>',
    '#value' => t('IMPORTANT:<p>The file test server does not perform node access checks related to the sending of file testing information. Only trust test servers that you have control over, as they are getting access to node information related to any file test sent, regardless of any node access control you impose on your site.</p><p>Keep the login information below confidential.</p>')
  );

  $form['pift_server_sites'] = array(
    '#type' => 'textarea',
    '#title' => t('Test sites'),
    '#default_value' => variable_get('pift_server_sites', ''),
    '#description' => t("List the login information and servers that will receive files for testing. Each site to receive information must have the <em>Project issue file test client</em> module installed, and you must include valid login information for a Drupal user on the test site who has the 'receive file test data' permission. Put one remote site per line, in the following format: <em>user::password::xmlrpc-url</em>. For example, <em>myusername::mypassword::http://example.com/xmlrpc.php</em>"),
  );

  $form['pift_server_file_description'] = array(
    '#type' => 'textarea',
    '#title' => t('Additional file description'),
    '#default_value' => variable_get('pift_server_file_description', ''),
    '#description' => t("Add text to the description of project issue file upload fields. Can by used to add clarification of files types, etc."),
  );

  $form['pift_failed_test_mail_text'] = array(
    '#type' => 'textarea',
    '#title' => t('Failed test e-mail'),
    '#default_value' => variable_get('pift_failed_test_mail_text', ''),
    '#description' => t("If a patch fails testing, and the user who wrote the patch is subscribed to receive notifications of test failures, an e-mail will be sent. Enter the body of the e-mail message above. Available tokens for the e-mail include: <em>!username, !site, !issue_title, !issue_url, !date, !reason, !filepath</em>. Leave blank to disable e-mail notifications."),
  );

  $form['pift_server_reset_send_queue'] = array(
    '#type' => 'checkbox',
    '#title' => t('Reset sending queue'),
    '#description' => t('If selected, the sending queue will be cleared, and only files submitted from the time of the reset will be sent.'),
  );

  $form['advanced'] = array(
    '#type' => 'fieldset',
    '#title' => t('Advanced settings'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );

  $form['advanced']['pift_send_limit'] = array(
    '#type' => 'textfield',
    '#title' => t('Send limit'),
    '#description' => t('Limit on how many files to send for each cron run. Default is 100.'),
    '#required' => TRUE,
    '#default_value' => variable_get('pift_send_limit', 100),
    '#size' => 10,
    '#maxlength' => 10,
    '#validate' => array('pift_server_is_numeric_validate' => array()),
  );

  $form['advanced']['pift_batch_size'] = array(
    '#type' => 'textfield',
    '#title' => t('Batch size'),
    '#description' => t('Number of files to send in a single call to a test server. Default is 20.'),
    '#required' => TRUE,
    '#default_value' => variable_get('pift_batch_size', 20),
    '#size' => 10,
    '#maxlength' => 10,
    '#validate' => array('pift_server_is_numeric_validate' => array()),
  );

  $form['advanced']['pift_file_regex'] = array(
    '#type' => 'textfield',
    '#title' => t('File regex'),
    '#description' => t('Regex for determining which file types should be sent for testing. Default is all files ending in <em>.patch</em> or <em>.diff</em>. You must include the full regex, ex. <em>/(\.diff|\.patch)$/</em>'),
    '#required' => TRUE,
    '#default_value' => variable_get('pift_file_regex', '/(\.diff|\.patch)$/'),
  );

  $form['advanced']['pift_resend_time'] = array(
    '#type' => 'textfield',
    '#title' => t('Re-send interval for untested files'),
    '#description' => t('Number of hours to wait before re-sending an untested file to a test server (ie, the test server never sent back the results). Default is 2 hours.'),
    '#required' => TRUE,
    '#default_value' => variable_get('pift_resend_time', 2),
    '#size' => 4,
    '#maxlength' => 4,
    '#validate' => array('pift_server_is_numeric_validate' => array()),
  );

  $form['advanced']['pift_retest_time'] = array(
    '#type' => 'textfield',
    '#title' => t('Re-test interval for previously passed files'),
    '#description' => t('Number of hours to wait before re-testing a previously passed file. Set to -1 to prevent re-testing. Default is 24 hours.'),
    '#required' => TRUE,
    '#default_value' => variable_get('pift_retest_time', 24),
    '#size' => 4,
    '#maxlength' => 4,
    '#validate' => array('pift_server_is_numeric_validate' => array()),
  );

  $form['advanced']['pift_retest_status'] = array(
    '#type' => 'textfield',
    '#title' => t('List of project statuses to re-test'),
    '#description' => t("Re-test previously passed tests that have the following status (should be a comma separated list of issue sids). Leave empty to re-test every status."),
    '#default_value' => variable_get('pift_retest_status', ''),
    '#validate' => array('pift_server_comma_separated_numeric_validate' => array()),
  );

  $form['advanced']['pift_projects'] = array(
    '#type' => 'textarea',
    '#title' => t('Projects to test'),
    '#description' => t("A comma separated list of project ID's (nids) that will be examined for new files. Leave empty for all projects."),
    '#default_value' => variable_get('pift_projects', ''),
    '#validate' => array('pift_server_comma_separated_numeric_validate' => array()),
  );

  // Custom submit handler
  $form['#submit']['pift_server_settings_form_extra_submit'] = array();
  // system_settings_form() doesn't add the default if #submit already exists.
  $form['#submit']['system_settings_form_submit'] = array();
  return system_settings_form($form);
}

/**
 * Validation for numeric textfields.
 */
function pift_server_is_numeric_validate($form) {
  if (!is_numeric($form['#value'])) {
    form_set_error($form['#name'], t('%title must be a number.', array('%title' => $form['#title'])));
  }
}

/**
 * Validation for comma separated numeric textfields.
 */
function pift_server_comma_separated_numeric_validate($form) {
  if ($values = $form['#value']) {
    $values = explode(',', $values);
    $values = array_map('trim', $values);
    foreach ($values as $value) {
      if (!is_numeric($value)) {
        form_set_error($form['#name'], t("%title must be a comma separated list of numeric ID's.", array('%title' => $form['#title'])));
        return;
      }
    }
  }
}

/**
 * Handles extra submission tasks on the admin settings page.
 */
function pift_server_settings_form_extra_submit($form_id, $values) {
  global $form_values;

  // Reset the queue.
  if ($values['pift_server_reset_send_queue']) {
    pift_server_reset_send_queue();
    drupal_set_message(t('Send queue reset.'));
  }
  // Remove the setting so it's not saved to {variable}.
  unset($form_values['pift_server_reset_send_queue']);
}

/**
 * Implementation of hook_menu().
 */
function pift_server_menu($may_cache) {
  $items = array();

  if ($may_cache) {
    $access_admin = user_access('administer projects');
    // Admin settings page.
    $items[] = array(
      'path' => 'admin/project/project-issue-file-test-server',
      'title' => t('Project issue file test server settings'),
      'description' => t('Configure sending file tests to test servers.'),
      'callback' => 'drupal_get_form',
      'callback arguments' => array('pift_server_settings_form'),
      'access' => $access_admin,
      'type' => MENU_NORMAL_ITEM,
    );
  }
  else {
    // Include the CSS file.
    drupal_add_css(drupal_get_path('module', 'pift_server') .'/pift_server.css');
  }

  return $items;
}

/**
 * Gets the most recently processed issue and comment ID.
 *
 * @return
 *   An associative array of information, as follows:
 *     'issue'    => The most recently processed issue nid.
 *     'followup' => The most recently processed comment cid.
 */
function pift_server_get_last() {

  $last_issue = variable_get('pift_server_last_issue_file_processed', 0);
  $last_followup = variable_get('pift_server_last_followup_file_processed', 0);

  return array('issue' => $last_issue, 'followup' => $last_followup);
}

/**
 * Gets the newest issue and comment ID.
 *
 * @return
 *   An associative array of information, as follows:
 *     'issue'    => The most recent issue nid.
 *     'followup' => The most recent comment cid.
 */
function pift_server_get_newest() {

  $newest_issue = db_result(db_query("SELECT MAX(fid) FROM {files}"));
  // No result, set to zero.
  $newest_issue = $newest_issue === FALSE ? 0 : $newest_issue;

  $newest_followup_file = db_result(db_query("SELECT MAX(fid) FROM {comment_upload_files}"));
  // No result, set to zero.
  $newest_followup_file = $newest_followup_file === FALSE ? 0 : $newest_followup_file;

  return array('issue' => $newest_issue, 'followup' => $newest_followup_file);
}

/**
 * Sets the last processed issue/followup to the most
 * recently posted issue/followup, sets the last sent
 * time to the current time, and empties the send queue.
 */
function pift_server_reset_send_queue() {
  $newest = pift_server_get_newest();
  variable_set('pift_server_last_issue_file_processed', $newest['issue']);
  variable_set('pift_server_last_followup_file_processed', $newest['followup']);
  variable_set('pift_server_last_sent', time());
  // Remove all untested files.
  // TODO: Do we really want to do this??
  db_query("DELETE FROM {pift_data} WHERE status = %d", PIFT_UNTESTED);
}

/**
 * Adds newly submitted issues/folowups to the send queue.
 */
function pift_server_add_new_files() {
  global $base_url;

  // Pull both the last items processed, and the newest items submitted.
  // This is the range that we can enter into the queue during this run.
  $last = pift_server_get_last();
  $newest = pift_server_get_newest();
  $data['issues'] = array();
  $data['followups'] = array();

  // Pull all new issue data. Limit the results to 5 times the PIFT_SEND_LIMIT for consistency.
  $issue_files = db_query_range("SELECT n.nid, n.uid, f.fid, f.filepath FROM {node} n INNER JOIN {files} f ON n.nid = f.nid WHERE n.type = 'project_issue' AND f.fid > %d AND f.fid <= %d AND f.filepath <> '' ORDER BY n.nid, f.fid", $last['issue'], $newest['issue'], 0, PIFT_SEND_LIMIT * 5);

  while ($file = db_fetch_object($issue_files)) {
    // Update last processed here, in case the server dies during the run.
    variable_set('pift_server_last_issue_file_processed', $file->fid);

    // Put the file data into the send queue.
    if (preg_match(PIFT_FILE_REGEX, basename($file->filepath)) && file_exists($file->filepath)) {
      $ftid = db_next_id('{pift_data}_ftid');
      db_query("INSERT INTO {pift_data} (ftid, fid, nid, cid, uid, display_data, status, timestamp) VALUES (%d, %d, %d, %d, %d, '%s', %d, %d)", $ftid, $file->fid, $file->nid, 0, $file->uid, '', PIFT_UNTESTED, 0);
    }
  }

  // Pull all new followup file data. Limit the results to 5 times the PIFT_SEND_LIMIT for consistency.
  $followup_files = db_query_range("SELECT n.nid, c.cid, c.uid, cu.fid, cu.filepath FROM {node} n INNER JOIN {comments} c ON n.nid = c.nid INNER JOIN {comment_upload_files} cu ON c.cid = cu.cid WHERE n.type = 'project_issue' AND cu.fid > %d AND cu.fid <= %d AND cu.filepath <> '' ORDER BY c.cid, cu.fid", $last['followup'], $newest['followup'], 0, PIFT_SEND_LIMIT * 5);

  while ($file = db_fetch_object($followup_files)) {
    // Update last processed here, in case the server dies during the run.
    variable_set('pift_server_last_followup_file_processed', $file->fid);

    // Put the file data into the send queue.
    if (preg_match(PIFT_FILE_REGEX, basename($file->filepath)) && file_exists($file->filepath)) {
      $ftid = db_next_id('{pift_data}_ftid');
      db_query("INSERT INTO {pift_data} (ftid, fid, nid, cid, uid, display_data, status, timestamp) VALUES (%d, %d, %d, %d, %d, '%s', %d, %d)", $ftid, $file->fid, $file->nid, $file->cid, $file->uid, '', PIFT_UNTESTED, 0);
    }
  }
}

/**
 * Marks previously passed files for re-testing, if:
 *   1. The file's last test is older than the retest interval.
 *   2. The file is part of a project that's being tested.
 *   3. The file is attached to an issue that has one of the
 *      issue states marked for testing.
 *
 */
function pift_server_retest_check() {

  // Never re-test files.
  if (PIFT_RESEND_TIME == '-1') {
    return;
  }

  // Set up the retest time limit.
  $retest_time = time() - (PIFT_RETEST_TIME * 60 * 60);

  $where = '';
  $where_parts = array();
  $args = array(PIFT_RETEST, PIFT_PASSED, $retest_time);

  // Restrict to listed projects, if set.
  if ($projects = pift_server_project_list()) {
    $where_parts[] = ' p.nid IN ('. implode(',', array_fill(0, count($projects), '%d')) .')';
    $args = array_merge($args, $projects);
  }

  // Restrict to the status list, if set.
  if ($status_list = pift_server_status_list()) {
    $where_parts[] = 'pi.sid IN ('. implode(',', array_fill(0, count($status_list), '%d')) .')';
    $args = array_merge($args, $status_list);
  }

  if (!empty($where_parts)) {
    $where .= " AND nid IN (SELECT pi.nid FROM {project_issues} pi INNER JOIN {node} p ON p.nid = pi.pid WHERE ". implode(' AND ', $where_parts) .")";
  }

  db_query("UPDATE {pift_data} SET status = %d WHERE status = %d AND timestamp < %d$where", $args);
}

/**
 * Sends file data to test servers, in a round robin approach.
 */
function pift_server_send_file_data() {
  global $base_url;

  // Get servers if any exist.
  if ($all_server_data = variable_get('pift_server_sites', '')) {
    $all_server_data = explode("\n", $all_server_data);
  }
  else {
    return;
  }

  // Add in release info if it exists.
  if (module_exists('project_release')) {
    $select = ', prn.version';
    $join = ' LEFT JOIN {project_release_nodes} prn ON pi.rid = prn.nid';
  }
  else {
    $select = '';
    $join = '';
  }

  // Set up the resend time limit.
  $resend_time = time() - (PIFT_RESEND_TIME * 60 * 60);

  $where = '';
  $where_args = array();
  $sub_query_args = array(PIFT_UNTESTED, $resend_time, PIFT_RETEST, 0);

  // Restrict to listed projects, if set.
  if ($projects = pift_server_project_list()) {
    $where .= ' AND p.nid IN ('. implode(',', array_fill(0, count($projects), '%d')) .')';
    $where_args = array_merge($where_args, $projects);
  }

  // Restrict to the status list, if set.
  if ($status_list = pift_server_status_list()) {
    $where .= ' AND pi.sid IN ('. implode(',', array_fill(0, count($status_list), '%d')) .')';
    $where_args = array_merge($where_args, $status_list);
  }

  // Assemble final args.
  $args = array_merge($sub_query_args, $where_args, $sub_query_args, $where_args);

  // Pull issue files that need to be sent for testing.  These include:
  // 1. All files marked as untested that have exceeded the resend period.
  //    since their last send (includes newly added files).
  // 2. All files that have been marked for re-testing.
  // This is one god awful query...  :(
  $files = db_query_range("(SELECT pd.ftid, n.nid AS issue_id, n.title AS issue_title, n.uid, pi.pid, pi.rid, f.filepath AS patch_url, p.title AS project, u.name AS submitter$select FROM {pift_data} pd INNER JOIN {project_issues} pi ON pd.nid = pi.nid INNER JOIN {files} f ON pd.fid = f.fid INNER JOIN {node} n ON n.nid = pi.nid INNER JOIN {node} p ON p.nid = pi.pid INNER JOIN {users} u ON u.uid = pd.uid$join WHERE ((pd.status = %d AND pd.timestamp < %d) OR pd.status = %d) AND pd.cid = %d$where) UNION (SELECT pd.ftid, n.nid AS issue_id, n.title AS issue_title, n.uid, pi.pid, pi.rid, cu.filepath AS patch_url, p.title AS project, u.name AS submitter$select FROM {pift_data} pd INNER JOIN {project_issues} pi ON pd.nid = pi.nid INNER JOIN {comment_upload_files} cu ON pd.fid = cu.fid INNER JOIN {node} n ON n.nid = pi.nid INNER JOIN {node} p ON p.nid = pi.pid INNER JOIN {users} u ON u.uid = pd.uid$join WHERE ((pd.status = %d AND pd.timestamp < %d) OR pd.status = %d) AND pd.cid <> %d$where) ORDER BY ftid", $args, 0, PIFT_SEND_LIMIT);

  // Nothing to do.
  if (!db_num_rows($files)) {
    return;
  }

  // Set up the batching variables.
  $bid = 0;
  $batches = array();
  $batch_total = 0;
  $sent_files = array();

  // Send new data if there is any.
  while ($file = db_fetch_array($files)) {
    if (is_readable($file['patch_url'])) {
      // Start the next batch if the current one is full.
      if ($batch_total >= PIFT_BATCH_SIZE) {
        $bid++;
        $batch_total = 0;
      }
      // Convert filepath to absolute URL.
      $file['patch_url'] = url($file['patch_url'], NULL, NULL, TRUE);
      // Add the file to the current batch.
      $batches[$bid][] = $file;
      // Add to the list of files that will be sent with this batch.
      $sent_files[$bid][] = $file['ftid'];
      // Increment both the current batch size, and the total size.
      $batch_total++;
    }
    // File is not readable, mark as such.
    else {
      db_query("UPDATE {pift_data} SET status = %d WHERE ftid = %d", PIFT_NOT_READABLE, $file['ftid']);
    }
  }

  $servers = array();
  $i = 0;

  // Set up the test servers.
  foreach ($all_server_data as $server_data) {
    if ($server_data) {
      // Set up the login data for the server. The test server needs
      // a username, password, and the base URL of the sending server.
      $server_data = explode('::', $server_data);
      $server['user'] = $server_data[0];
      $server['pass'] = $server_data[1];
      $server['url'] = $base_url .'/xmlrpc.php';
      $server['xmlrpc_url'] = $server_data[2];
      // Basic testing to make sure the XML-RPC URL isn't totally bogus.
      if (preg_match('/^(http|https):\/\/.+\/xmlrpc.php/', $server['xmlrpc_url'])) {
        $i++;
        $servers[$i] = $server;
      }
      // Bad server URL.
      else {
        watchdog('project_remote', t('%server is an invalid URL.', array('%server' => $server_xmlrpc_url)), WATCHDOG_ERROR);
      }
    }
  }

  $sent = array();

  // Get the next server in the round robin cycle.
  $s = variable_get('pift_next_test_server', 1);

  // Send batches, round robin.
  foreach ($batches as $bid => $batch) {
    // We're at the end of the server line, start over.
    if ($s > $i) {
      $s = 1;
    }
    // Send batch.
    $result = xmlrpc($servers[$s]['xmlrpc_url'], 'pift.test.files', $servers[$s], $batch);

    // Failed XML-RPC call.
    if ($result === FALSE) {
      pift_server_xmlrpc_error_handler($servers[$s]);
    }
    // Failed test server validation.
    elseif (isset($result['error'])) {
      pift_server_xmlrpc_error_handler($servers[$s], $result['error']);
    }
    // List of successful sends.
    else {
      // Update the last sent timestamp for this batch of files.
      db_query("UPDATE {pift_data} SET timestamp = %d WHERE ftid IN (". implode(', ', $sent_files[$bid]) .")", time());
      $sent[] = check_plain($servers[$s]['xmlrpc_url']);
    }
    // Next server in line.
    $s++;
    variable_set('pift_next_test_server', $s);
  }

  // Record successful sends.
  if (!empty($sent)) {
    watchdog('project_remote', t('Project issue data sent successfully to the following servers:!servers', array('!servers' => theme('item_list', $sent))));
  }
}

/**
 * Ensure that the given user has permission to return file test results.
 */
function pift_server_validate_user($username, $password) {
  global $user;

  $user = user_authenticate($username, $password);

  if ($user->uid) {
    if (user_access('administer projects', $user)) {
      return $user;
    }
  }

  return FALSE;
}

/**
 * Implementation of hook_xmlrpc()
 */
function pift_server_xmlrpc() {
  return array(
    array(
      'pift.test.results',
      'pift_server_process_test_results',
      array('boolean', 'struct', 'struct'),
      t('receive file test results from a test server')
    ),
  );
}

/**
 * Validates incoming test results and passes them along for processing.
 *
 * @param $server
 *   An associative array of login parameters, as follows:
 *     'user' => The username to log in.
 *     'pass' => The user's password.
 *     'url'  => The Drupal base URL of the server sending the data.
 *
 * @param $files
 *   An array of files to process. Each element an associative array
 *   of information for one file, as follows:
 *     'ftid'         => The file test ID that was originally passed to
 *                       the test server for the file in question.
 *
 *     'status'       => The file's test status (passed, failed, etc.).
 *
 *     'display_data' => Optional. A string of additional data to display
 *                       when rendering the file test results.
 *
 * @return
 *   TRUE if the test data was properly validated, FALSE otherwise.
 */
function pift_server_process_test_results($server, $files) {
  // Build an array of valid test servers for this install.
  $test_servers = explode("\n", variable_get('pift_server_sites', ''));
  $valid_servers = array();
  foreach ($test_servers as $test_server) {
    if ($test_server) {
      $parts = explode('::', $test_server);
      $valid_servers[] = $parts[2];
    }
  }
  // Validate the test server URL against the list of valid test servers.
  if (in_array($server['url'], $valid_servers)) {
    // Validate the user submitting the test results.
    if (pift_server_validate_user($server['user'], $server['pass'])) {
      pift_server_process_files($files);
      return array();
    }
    // Bad login.
    else {
      watchdog('project_remote', t('Invalid user %user tried to send project issue file test data.', array('%user' => $server['user'])), WATCHDOG_WARNING);
      return array('error' => 'PIFT_XMLRPC_INVALID_USER');
    }
  }
  // Bad test server.
  else {
    watchdog('project_remote', t('%server attempted to file test data, and is not on the valid server list.', array('%server' => $server['url'])), WATCHDOG_WARNING);
    return array('error' => 'PIFT_XMLRPC_INVALID_SERVER');
  }
}

/**
 * Processing incoming file tests, and stores the results.
 *
 * @param $files
 *   An array of files to process. Each element an associative array
 *   of information for one file, as follows:
 *     'ftid'         => The file test ID that was originally passed to
 *                       the test server for the file in question.
 *
 *     'status'       => The file's test status (passed, failed, etc.).
 *
 *     'display_data' => Optional. A string of addition data to display
 *                       when rendering the file test results.
 */
function pift_server_process_files($files) {
  $ftids = array();
  $time = time();
  foreach ($files as $file) {
    // Update the entry that was originally entered for this file,
    // and set the last tested timestamp to the current time.
    db_query("UPDATE {pift_data} SET display_data = '%s', status = %d, timestamp = %d WHERE ftid = %d", $file['display_data'], $file['status'], $time, $file['ftid']);
    $ftids[] = $file['ftid'];
  }
  pift_server_mail_failed_tests($ftids);
}

/**
 * E-mails subscribed users when their file fails regression testing.
 *
 * @param $ftids
 *   An array of file test ID's to check for failure.
 */
function pift_server_mail_failed_tests($ftids) {
  // E-mail functionality is disabled.
  if (!($mail_text = variable_get('pift_failed_test_mail_text', ''))) {
    return;
  }

  // Filter out bad/risky data.
  $ftids = array_filter($ftids, 'is_numeric');
  if (!empty($ftids)) {
    $site_name = variable_get('site_name', 'Drupal');

    // Pull only the file data for files that have failed, and that
    // relate to a use that's subscribe to receive test failure emails.
    $issue_emails = db_query("SELECT u.name, u.mail, n.title, pd.fid, pd.nid, pd.cid, pd.display_data FROM {pift_data} pd INNER JOIN {node} n ON n.nid = pd.nid INNER JOIN {pift_subscriptions} ps ON pd.uid = ps.uid INNER JOIN {users} u ON u.uid = pd.uid WHERE n.status = 1 AND u.status = 1 AND pd.ftid IN (". implode(', ', $ftids) .") AND pd.status = %d", PIFT_FAILED);

    while ($mail = db_fetch_object($issue_emails)) {

      // Pull the filepath here, since we can't get it from the query above --
      // it could be coming from two different places. Send user directly to
      // the comment if the file was attached to a comment.
      if ($mail->cid) {
        $table = '{comment_upload_files}';
        $fragment = "comment-$mail->cid";
      }
      else {
        $table = '{files}';
        $fragment = NULL;
      }
      $filepath = db_result(db_query("SELECT filepath FROM $table WHERE fid = %d", $mail->fid));

      if (is_readable($filepath)) {
        $variables = array(
          '!username' => $mail->name,
          '!site' => $site_name,
          '!issue_title' => $mail->title,
          '!issue_url' => url('node/'. $mail->nid, NULL, $fragment, TRUE),
          '!date' => format_date(time()),
          '!reason' => $mail->display_data,
          '!filepath' => url($filepath, NULL, NULL, TRUE),
        );

        $body = strtr($mail_text, $variables);
        $subject = t('!site Testbed server', array('!site' => $site_name));
        drupal_mail('pift_failed_test', $mail->mail, $subject, $body);
      }
    }
  }
}

/**
 * Implementation of hook_nodeapi().
 */
function pift_server_nodeapi(&$node, $op, $arg) {
  // Only display test results for issue nodes when it's a full view.
  if ($node->type == 'project_issue' && arg(0) == 'node' && is_numeric(arg(1))) {
    switch ($op) {
      case 'view':
        // Pull file attachments for this issue node.
        $result = db_query("SELECT f.filepath, pd.display_data, pd.status FROM {pift_data} pd INNER JOIN {files} f ON pd.fid = f.fid WHERE pd.nid = %d AND pd.cid = %d AND f.filepath <> '' AND pd.status <> %d ORDER BY ftid", $node->nid, 0, PIFT_UNTESTED);
        $display = array();

        // Load the files into an array to pass to the theming function.
        while ($file = db_fetch_array($result)) {
          $display[] = array(
            'filepath' => $file['filepath'],
            'status' => $file['status'],
            'display_data' => filter_xss_admin($file['display_data']),  // Coming from a trusted server, relaxed filtering.
          );
        }
        // Display table just below file attachment.
        $node->content['file_test_data'] = array(
          '#value' => theme('pift_server_results', $display),
          '#weight' => 51,  // Just below the upload attachments.
        );
        break;
      case 'delete':
        // Remove related data in the test results table.
        db_query("DELETE FROM {pift_data} WHERE nid = %d", $node->nid);
        break;
      case 'update':
        // If files were deleted, remove related data in the test results table.
        if (is_array($node->files)) {
          foreach ($node->files as $file) {
            // Can be either an array or object as this point.
            $file = (object) $file;
            if ($file->remove) {
              db_query("DELETE FROM {pift_data} WHERE cid = %d AND fid = %d", $comment['cid'], $file->fid);
            }
          }
        }
        break;
    }
  }
}

/**
 * Implementation of hook_user().
 */
function pift_server_user($type, $edit, &$user, $category = NULL) {
  if ($type == 'delete') {
    db_query("DELETE FROM {pift_subscriptions} WHERE uid = %d", $user->uid);
    db_query("UPDATE {pift_data} SET uid = 0 WHERE uid = %d", $user->uid);
  }
}

/**
 * Implementation of hook_comment().
 */
function pift_server_comment(&$comment, $op) {
  static $cids = NULL;

  // $comment can be a comment object, or a form or form_values.
  if (is_object($comment)) {
    $nid = $comment->nid;
  }
  elseif (is_array($comment)) {
    $nid = is_array($comment['nid']) ? $comment['nid']['#value'] : $comment['nid'];
  }
  $node = node_load($nid);
  if ($node->type != 'project_issue') {
    return;
  }

  switch ($op) {
    case 'view':

      // To boost performance, cache the test results for all issue followups
      // at once, then grab the display data from the cache.
      if (!isset($cids)) {
        $cids = array();
        // Pull file attachments for all followups on the issue.
        $result = db_query("SELECT cu.cid, cu.filepath, cu.description, pd.display_data, pd.status FROM {pift_data} pd INNER JOIN {comment_upload_files} cu ON pd.fid = cu.fid WHERE pd.nid = %d AND pd.cid <> %d AND status <> %d ORDER BY ftid", $node->nid, 0, PIFT_UNTESTED);

        // Load the files into an array to pass to the theming function.
        while ($file = db_fetch_array($result)) {
          $cids[$file['cid']][] = array(
            'filepath' => $file['filepath'],
            'description' => $file['description'],
            'status' => $file['status'],
            'display_data' => filter_xss_admin($file['display_data']),
          );
        }

        // Convert the results to themed display tables.
        foreach ($cids as $cid => $display) {
          $cids[$cid] = theme('pift_server_results', $display);
        }
      }

      // Add the test result display to the end of the comment.
      // TODO: When comment module's rendering isn't so whack,
      // always put this right after the attachment table.
      if (!empty($cids[$comment->cid])) {
        $comment->comment .= $cids[$comment->cid];
      }
      break;
    case 'update':
      // If files were deleted, remove related data in the test results table.
      if (is_array($comment['files'])) {
        foreach ($comment['files'] as $file) {
          // Can be either an array or object as this point.
          $file = (object) $file;
          if ($file->remove) {
            db_query("DELETE FROM {pift_data} WHERE cid = %d AND fid = %d", $comment['cid'], $file->fid);
          }
        }
      }
      break;
    case 'delete':
      // Remove related data in the test results table.
      db_query("DELETE FROM {pift_data} WHERE cid = %d", $comment->cid);
      break;
  }
}

/**
 * Theme test result data into a table.
 *
 * @param $results
 *   An array of test result data.
 * @return
 *   An HTML string of the rendered table.
 */
function theme_pift_server_results($results) {
  $rows = array();
  $output = '';

  // One row for each file test result.
  foreach ($results as $result) {
    $description = $result['description'] ? $result['description'] : basename($result['filepath']);
    switch ($result['status']) {
      // File passed testing.
      case PIFT_PASSED:
        $rows[] = array(
          'data' => array(
            $description,
            t('passed'),
            $result['display_data'],  // Already filtered.
          ),
          'class' => 'pift-passed',
        );
        break;
      // File failed testing.
      case PIFT_FAILED:
        $rows[] = array(
          'data' => array(
            $description,
            t('failed'),
            $result['display_data'],  // Already filtered.
          ),
          'class' => 'pift-failed',
        );
        break;
    }
  }

  // Only build the table if there are results to display.
  if (!empty($rows)) {
    $header = array(
      array(
        'data' => t('Testbed results'),
        'colspan' => '3',
      )
    );
    $output = '<div class="file-test-results">'. theme('table', $header, $rows) .'</div>';
  }

  return $output;
}

/**
 * Records XML-RPC errors communicating to test servers.
 *
 * @param $server
 *   An associative array of server information, as follows:
 *     'user' => The user logging in.
 *     'xmlrpc_url' => The XML-RPC URL of the test server.
 *     'url'  => The Drupal base URL of the server sending the data.
 *
 * @param $error_code
 *   Optional. A string representing a validation error type.
 */
function pift_server_xmlrpc_error_handler($server, $error_code = NULL) {
  global $base_url;

  $t_args = array('%url' => $base_url, '%xmlrpc_url' => $server['xmlrpc_url'], '%user' => $server['user']);

  switch ($error_code) {
    case 'PIFT_XMLRPC_INVALID_SERVER':
      watchdog('project_remote', t('%url is not listed as a valid project server at test server %xmlrpc_url', $t_args), WATCHDOG_ERROR);
      break;
    case 'PIFT_XMLRPC_INVALID_USER':
      watchdog('project_remote', t('Unable to log in %url to %xmlrpc_url using user %user, due to invalid login credentials or insufficient user permissions.', $t_args), WATCHDOG_ERROR);
      break;
    default:
      watchdog('project_remote', t('XML-RPC error communicating with %xmlrpc_url', $t_args), WATCHDOG_ERROR);
      break;
  }
}

/**
 * Checks to see if the project is currently being monitored by
 * pift_s for file testing.
 *
 * @param $pid
 *   The project nid.
 * @return
 *   TRUE if the project is in the active project list, or if the list
 *   is empty.  FALSE otherwise.
 */
function pift_server_active_project($pid) {
  if ($projects = pift_server_project_list()) {
    return in_array($pid, $projects);
  }
  else {
    return TRUE;
  }
}

/**
 * Formats the active project list into an array.
 *
 * @return
 *   An array of the active projects that will be examined for testing.
 */
function pift_server_project_list() {
  if ($projects = variable_get('pift_projects', '')) {
    $projects = explode(',', $projects);
    $projects = array_map('trim', $projects);
    return $projects;
  }
  else {
    return array();
  }
}

/**
 * Formats the active status list into an array.
 *
 * @return
 *   An array of the statuses that will be examined for re-testing.
 */
function pift_server_status_list() {
  if ($status_list = variable_get('pift_retest_status', '')) {
    $status_list = explode(',', $status_list);
    $status_list = array_map('trim', $status_list);
    return $status_list;
  }
  else {
    return array();
  }
}
